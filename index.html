<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    // Redirect to protected Cloudflare version if accessed directly from GitHub
    if (window.location.hostname.includes('github.io')) {
      window.location.replace('https://nba-trade-calculator.thejorgesierra.workers.dev/');
    }
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NBA Trade Machine</title>
  
  <!-- Open Graph / Social Sharing Meta Tags (dynamically replaced by Cloudflare Worker) -->
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Hoopsmatic">
  <meta property="og:url" content="https://hoopsmatic.com/">
  <meta property="og:title" content="NBA Trade Machine">
  <meta property="og:description" content="Create and share NBA trades with real salary cap rules">
  <meta property="og:image" content="https://i.imgur.com/EtRP1fQ.jpeg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="NBA Trade Machine">
  <meta name="twitter:description" content="Create and share NBA trades with real salary cap rules">
  <meta name="twitter:image" content="https://i.imgur.com/EtRP1fQ.jpeg">
  <meta name="description" content="Create and share NBA trades with real salary cap rules. Includes salary matching, draft picks, trade exceptions, and all 2024-25 CBA rules.">
  <!-- END OG Meta Tags -->
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f5f5f7;
      --surface: #ffffff;
      --surface-hover: #f0f0f2;
      --border: #d1d1d6;
      --text: #1d1d1f;
      --text-secondary: #6e6e73;
      --accent: #3b82f6;
      --accent-dim: rgba(59, 130, 246, 0.15);
      --green: #34c759;
      --green-dim: rgba(52, 199, 89, 0.15);
      --orange: #b45309;
      --orange-dim: rgba(180, 83, 9, 0.15);
      --red: #ff453a;
      --red-dim: rgba(255, 69, 58, 0.15);
      --valid: #34c759;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
    }

    header {
      margin-bottom: 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      letter-spacing: -0.03em;
    }

    .header-actions {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      width: 100%;
    }

    .header-row {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .trade-machine {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .unified-trade-machine {
      display: flex;
      gap: 1rem;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .unified-input-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .unified-label {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .unified-trade-machine .player-search-input {
      width: 160px;
    }

    .unified-trade-machine .exclusion-input {
      width: 120px !important;
    }

    .unified-trade-machine .btn-primary {
      margin-bottom: 0;
    }

    .unified-trade-machine > span {
      margin-bottom: 0.5rem;
    }

    .player-search-input:disabled {
      background: var(--bg);
      color: var(--text-secondary);
      cursor: not-allowed;
    }

    .player-search-input {
      padding: 0.625rem 1rem;
      font-size: 0.875rem;
      font-family: inherit;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      width: 200px;
      transition: all 0.15s;
    }

    .player-search-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    .player-search-input::placeholder {
      color: var(--text-secondary);
    }

    .btn {
      padding: 0.625rem 1.25rem;
      font-size: 0.875rem;
      font-family: inherit;
      font-weight: 500;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      border: none;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #2563eb;
    }

    .btn-secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--surface-hover);
    }

    .btn-danger {
      background: var(--red-dim);
      color: var(--red);
      border: 1px solid transparent;
    }

    .btn-danger:hover {
      background: var(--red);
      color: white;
    }

    .btn-success {
      background: var(--green-dim);
      color: var(--green);
      border: 1px solid transparent;
    }

    .btn-success:hover {
      background: var(--green);
      color: white;
    }

    .btn-loop {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-loop:hover {
      background: var(--surface-hover);
    }

    .btn-loop.active {
      background: var(--orange);
      color: white;
      border-color: var(--orange);
      animation: pulse 2s ease-in-out infinite;
    }

    .btn-share-loop {
      background: var(--accent);
      color: white;
      border: 1px solid var(--accent);
    }

    .btn-share-loop:hover {
      background: #2563eb;
      border-color: #2563eb;
    }

    .btn-share-loop.copied {
      background: var(--green);
      border-color: var(--green);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Multi-player selection container */
    .multi-player-container {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
    }

    .selected-players-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      max-width: 300px;
    }

    .selected-player-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      background: var(--accent-dim);
      border: 1px solid var(--accent);
      border-radius: 12px;
      font-size: 0.75rem;
      color: var(--accent);
      white-space: nowrap;
    }

    .selected-player-chip-remove {
      cursor: pointer;
      font-weight: bold;
      opacity: 0.7;
    }

    .selected-player-chip-remove:hover {
      opacity: 1;
    }

    /* Exclusion container */
    .exclusion-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      position: relative;
    }

    .exclusion-input {
      width: 160px !important;
    }

    .excluded-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      max-width: 300px;
    }

    .excluded-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      background: var(--red-dim);
      border: 1px solid var(--red);
      border-radius: 12px;
      font-size: 0.75rem;
      color: var(--red);
      white-space: nowrap;
    }

    .excluded-chip-remove {
      cursor: pointer;
      font-weight: bold;
      opacity: 0.7;
    }

    .excluded-chip-remove:hover {
      opacity: 1;
    }

    /* Image Modal */
    .image-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .image-modal-content {
      background: var(--surface);
      border-radius: 12px;
      max-width: 90%;
      max-height: 90%;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .image-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
    }

    .image-modal-header h3 {
      margin: 0;
      font-size: 1.125rem;
    }

    .image-modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0;
      line-height: 1;
    }

    .image-modal-close:hover {
      color: var(--text);
    }

    .image-modal-body {
      padding: 1.5rem;
      overflow: auto;
      max-height: 60vh;
    }

    .image-modal-body img {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .image-modal-footer {
      display: flex;
      gap: 1rem;
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      justify-content: center;
    }

    .format-selector {
      display: flex;
      gap: 0.5rem;
    }

    .format-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text-secondary);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .format-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .format-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .trade-container {
      display: flex;
      gap: 1rem;
      overflow-x: auto;
      padding-bottom: 1rem;
    }

    .team-card {
      flex: 1;
      min-width: 280px;
      max-width: 320px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      overflow: visible;
    }

    .team-card.valid {
      border-color: var(--green);
    }

    .team-card.invalid {
      border-color: var(--red);
    }

    .team-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .team-select {
      flex: 1;
      padding: 0.5rem;
      font-size: 0.9375rem;
      font-family: inherit;
      font-weight: 600;
      background: transparent;
      border: none;
      color: var(--text);
      cursor: pointer;
      outline: none;
    }

    .team-select.pulse-hint {
      animation: selectPulse 1s ease-in-out 3;
    }

    @keyframes selectPulse {
      0%, 100% { 
        background: transparent; 
      }
      50% { 
        background: rgba(99, 102, 241, 0.15);
        border-radius: 6px;
      }
    }

    .team-select option {
      background: var(--surface);
      color: var(--text);
    }

    .remove-team-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 0.25rem;
      font-size: 1.25rem;
      line-height: 1;
      transition: color 0.15s;
    }

    .remove-team-btn:hover {
      color: var(--red);
    }

    .team-status {
      padding: 0.5rem 1rem;
      background: var(--surface-hover);
      font-size: 0.75rem;
      color: var(--text-secondary);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .team-status-item {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .team-body {
      padding: 1rem;
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .trade-content {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .roster-section {
      border-top: 2px dashed var(--border);
      padding-top: 0.75rem;
      margin-top: 0.75rem;
    }

    .section-label {
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0;
      margin-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .section-header-logo {
      width: 24px;
      height: 24px;
      object-fit: contain;
    }

    .section-header-text {
      font-size: 0.8125rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .section-header-text.trades {
      color: var(--red);
    }

    .section-header-text.acquires {
      color: var(--green);
    }

    .section-header-select {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      font-family: inherit;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      cursor: pointer;
    }

    .players-out, .players-in {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .player-chip {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0.75rem;
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 6px;
      font-size: 0.8125rem;
      flex-wrap: wrap;
      gap: 0.375rem;
      overflow: visible;
    }

    .player-chip-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      overflow: visible;
    }

    .player-headshot {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 0.5rem;
      flex-shrink: 0;
      background: var(--surface-hover);
    }

    .team-logo {
      width: 28px;
      height: 28px;
      object-fit: contain;
      margin-right: 0.5rem;
      flex-shrink: 0;
    }

    .player-chip-info {
      display: flex;
      flex-direction: column;
      gap: 0.125rem;
      flex: 1;
      min-width: 0;
      overflow: visible;
    }

    .player-chip-name {
      font-weight: 500;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.375rem;
      row-gap: 0.25rem;
      max-width: 100%;
      overflow: visible;
    }
    
    .player-info-wrapper {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .player-chip-salary {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      flex-shrink: 0;
      margin-top: 0.125rem;
    }

    .player-chip-remove {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1rem;
      padding: 0.25rem;
      line-height: 1;
    }

    .player-chip-remove:hover {
      color: var(--red);
    }

    .player-destination {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 0.375rem;
      font-size: 0.6875rem;
      color: var(--text-secondary);
    }

    .player-destination-label {
      white-space: nowrap;
    }

    .player-destination-select {
      flex: 1;
      padding: 0.25rem 0.375rem;
      font-size: 0.6875rem;
      font-family: inherit;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
    }

    .player-destination-select option {
      background: var(--surface);
    }

    .player-chip.incoming {
      background: var(--accent-dim);
      border: 1px solid var(--accent);
    }

    .player-chip.incoming .player-chip-remove {
      display: none;
    }

    .add-player-container {
      position: relative;
      margin-top: auto;
    }

    .add-player-input {
      width: 100%;
      padding: 0.625rem 0.75rem;
      font-size: 0.8125rem;
      font-family: inherit;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      outline: none;
    }

    .add-player-input:focus {
      border-color: var(--accent);
    }

    .add-player-input::placeholder {
      color: var(--text-secondary);
    }

    .player-dropdown {
      position: absolute;
      bottom: calc(100% + 4px);
      left: 0;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      max-height: 240px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .player-dropdown.active {
      display: block;
    }

    .player-dropdown-item {
      padding: 0.625rem 0.75rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      font-size: 0.8125rem;
    }

    .player-dropdown-item:last-child {
      border-bottom: none;
    }

    .player-dropdown-item:hover {
      background: var(--surface-hover);
    }

    .player-dropdown-item-salary {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .team-footer {
      padding: 0.75rem;
      margin-top: 0.5rem;
      background: var(--surface-hover);
      border-radius: 8px;
    }

    .salary-summary {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
      font-size: 0.8125rem;
    }

    .salary-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .salary-label {
      color: var(--text-secondary);
    }

    .salary-value {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
    }

    .salary-value.negative {
      color: var(--red);
    }

    .salary-value.positive {
      color: var(--green);
    }

    .salary-row.total {
      padding-top: 0.375rem;
      margin-top: 0.375rem;
      border-top: 1px solid var(--border);
      font-weight: 600;
    }

    .trade-status {
      margin-bottom: 1.5rem;
      padding: 1rem;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .trade-status.valid {
      background: var(--green-dim);
      border: 1px solid var(--green);
    }

    .trade-status.pending {
      background: var(--green-dim);
      border: 1px solid var(--green);
    }

    .trade-status.pending .trade-status-message {
      color: var(--orange);
    }

    .trade-status.invalid {
      background: var(--red-dim);
      border: 1px solid var(--red);
    }

    .trade-status.warning {
      background: var(--orange-dim);
      border: 1px solid var(--orange);
    }

    .trade-status-icon {
      font-size: 1.5rem;
    }

    .trade-status-text {
      flex: 1;
    }

    .trade-status-title {
      font-weight: 600;
      font-size: 0.9375rem;
    }

    .trade-status-message {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      margin-top: 0.125rem;
    }

    .check-rumors-link {
      margin-left: auto;
      padding: 0.5rem 1rem;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--accent);
      text-decoration: none;
      border: 1px solid var(--accent);
      border-radius: 6px;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .check-rumors-link:hover {
      background: var(--accent);
      color: white;
    }

    .add-team-card {
      min-width: 200px;
      max-width: 200px;
      background: var(--surface);
      border: 2px dashed var(--border);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      min-height: 400px;
    }

    .add-team-card:hover {
      border-color: var(--accent);
      background: var(--surface-hover);
    }

    .add-team-content {
      text-align: center;
      color: var(--text-secondary);
    }

    .add-team-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .add-team-text {
      font-size: 0.875rem;
      font-weight: 500;
    }

    .player-roster {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg);
      overflow: visible;
    }

    .player-roster-item {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      font-size: 0.8125rem;
      transition: background 0.15s;
      gap: 0.5rem;
    }

    .roster-headshot {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--surface-hover);
    }

    .roster-headshot-placeholder {
      width: 28px;
      height: 28px;
      flex-shrink: 0;
    }

    .player-roster-item:last-child {
      border-bottom: none;
    }

    .player-roster-item:hover {
      background: var(--surface-hover);
    }

    .player-roster-item.disabled {
      cursor: not-allowed;
    }
    
    /* Info icon should still be interactive on disabled items */
    .player-roster-item.disabled .player-info-wrapper {
      cursor: help;
    }
    
    /* Use color change instead of opacity so tooltip stays visible */
    .player-roster-item.disabled > .roster-headshot {
      opacity: 0.4;
    }
    
    .player-roster-item.disabled > .roster-headshot-placeholder {
      opacity: 0.4;
    }
    
    .player-roster-item.disabled > .player-roster-name {
      color: var(--text-secondary);
    }
    
    .player-roster-item.disabled > .player-roster-salary {
      opacity: 0.4;
    }

    .player-roster-item.disabled:hover {
      background: transparent;
    }

    .player-roster-name {
      font-weight: 500;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.375rem;
      row-gap: 0.2rem;
      flex: 1;
      min-width: 0;
      padding-right: 0.5rem;
    }

    .player-roster-salary {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--text-secondary);
      flex-shrink: 0;
      white-space: nowrap;
    }
    
    .trending-badge {
      font-size: 0.75rem;
      cursor: help;
      flex-shrink: 0;
    }

    .tpe-section {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: var(--surface-hover);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    .tpe-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .tpe-label {
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .tpe-list {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
    }

    .tpe-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: var(--bg);
      border-radius: 4px;
      font-size: 0.8125rem;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.15s;
    }

    .tpe-item:hover {
      border-color: var(--accent);
    }

    .tpe-item.selected {
      border-color: var(--green);
      background: var(--green-dim);
    }

    .tpe-item.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .tpe-value {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
      color: var(--green);
    }

    .tpe-expiry {
      font-size: 0.6875rem;
      color: var(--text-secondary);
    }

    .tpe-used-badge {
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      background: var(--green-dim);
      color: var(--green);
      border-radius: 3px;
      font-weight: 600;
    }

    .picks-section {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: var(--surface-hover);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    .picks-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .picks-label {
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .picks-list {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
    }

    .pick-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: var(--bg);
      border-radius: 4px;
      font-size: 0.8125rem;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.15s;
    }

    .pick-item:hover {
      border-color: var(--accent);
    }

    .pick-item.selected {
      border-color: var(--orange);
      background: var(--orange-dim);
    }

    .pick-item.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .pick-year {
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      color: var(--orange);
    }

    .pick-round {
      font-size: 0.6875rem;
      color: var(--text-secondary);
      margin-left: 0.25rem;
    }

    .pick-notes {
      font-size: 0.625rem;
      color: var(--text-secondary);
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .pick-conditional {
      font-size: 0.5625rem;
      padding: 0.125rem 0.3rem;
      border-radius: 3px;
      font-weight: 600;
      background: var(--red-dim);
      color: var(--red);
      margin-left: 0.25rem;
    }

    .picks-traded-badge {
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      background: var(--orange-dim);
      color: var(--orange);
      border-radius: 3px;
      font-weight: 600;
    }

    .rights-section {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: var(--surface-hover);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    .rights-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .rights-label {
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .rights-list {
      display: flex;
      flex-direction: column;
      gap: 0.375rem;
    }

    .rights-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: var(--bg);
      border-radius: 4px;
      font-size: 0.8125rem;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.15s;
    }

    .rights-item:hover {
      border-color: var(--accent);
    }

    .rights-item.selected {
      border-color: #a855f7;
      background: rgba(168, 85, 247, 0.15);
    }

    .rights-item.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .rights-name {
      font-weight: 500;
      color: #a855f7;
    }

    .rights-year {
      font-size: 0.6875rem;
      color: var(--text-secondary);
      margin-left: 0.25rem;
    }

    .rights-traded-badge {
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      background: rgba(168, 85, 247, 0.15);
      color: #a855f7;
      border-radius: 3px;
      font-weight: 600;
    }

    .cash-section {
      margin-top: 0.75rem;
      padding: 0.75rem;
      background: var(--surface-hover);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    .cash-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: var(--bg);
      border-radius: 4px;
      font-size: 0.8125rem;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.15s;
    }

    .cash-item:hover {
      border-color: var(--accent);
    }

    .cash-item.selected {
      border-color: #22c55e;
      background: rgba(34, 197, 94, 0.15);
    }

    .cash-label {
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .ntc-badge, .restriction-badge, .na-badge, .pp-badge, .min-badge, .tw-badge {
      font-size: 0.5625rem;
      padding: 0.125rem 0.3rem;
      border-radius: 3px;
      font-weight: 600;
      text-transform: uppercase;
      cursor: help;
    }

    .ntc-badge {
      background: var(--orange-dim);
      color: var(--orange);
    }

    .restriction-badge {
      background: var(--red-dim);
      color: var(--red);
    }

    .na-badge {
      background: rgba(168, 85, 247, 0.15);
      color: #a855f7;
    }

    .pp-badge {
      background: rgba(236, 72, 153, 0.15);
      color: #ec4899;
    }

    .min-badge {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
    }

    .mse-badge {
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }

    .tk-badge {
      background: rgba(249, 115, 22, 0.15);
      color: #f97316;
    }

    .tw-badge {
      background: rgba(59, 130, 246, 0.15);
      color: #3b82f6;
    }

    .injury-badge {
      cursor: help;
      font-size: 0.65rem;
      font-weight: 700;
      color: #ff0000;
      background: white;
      border: 1.5px solid #ff0000;
      padding: 0 0.15rem;
      border-radius: 2px;
      margin-left: 0.2rem;
    }

    .player-info-wrapper {
      position: relative;
      display: inline-flex;
      align-items: center;
      margin-right: 0.35rem;
    }

    .player-info-icon {
      font-size: 0.75rem;
      width: 18px;
      height: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background: rgba(100, 100, 100, 0.15);
      color: #6b7280;
      margin-left: 0.25rem;
      cursor: help;
      transition: all 0.15s;
    }

    .player-info-icon:hover {
      background: var(--accent);
      color: white;
    }

    .player-info-tooltip {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      transform: translateX(0);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      min-width: 220px;
      max-width: 280px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.15s;
      pointer-events: none;
    }

    .player-info-wrapper:hover .player-info-tooltip {
      opacity: 1;
      visibility: visible;
    }

    .player-info-tooltip::after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 20px;
      transform: translateX(0);
      border: 6px solid transparent;
      border-bottom-color: var(--border);
    }

    .player-info-name {
      font-weight: 600;
      font-size: 0.875rem;
      margin-bottom: 0.25rem;
      color: var(--text);
    }

    .player-info-team {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .player-info-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      padding: 0.2rem 0;
      border-bottom: 1px solid var(--border);
    }

    .player-info-row:last-child {
      border-bottom: none;
    }

    .player-info-label {
      color: var(--text-secondary);
    }

    .player-info-value {
      font-weight: 500;
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
    }

    .loading {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--text-secondary);
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .divider {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.5rem 0;
    }

    .divider-line {
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .divider-text {
      font-size: 0.625rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      max-height: 250px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .autocomplete-dropdown.show {
      display: block;
    }

    .autocomplete-item {
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 0.875rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-item:hover {
      background: var(--surface-hover);
    }

    .autocomplete-item.selected {
      background: var(--accent);
      color: white;
    }

    .autocomplete-item .player-team {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .autocomplete-item.selected .player-team {
      color: rgba(255, 255, 255, 0.7);
    }

    @media (max-width: 768px) {
      .container {
        padding: 0.5rem;
      }

      header {
        margin-bottom: 1rem;
      }

      h1 {
        font-size: 1.25rem;
        margin-bottom: 0.75rem;
      }

      .header-actions {
        gap: 0.5rem;
      }

      .header-row {
        gap: 0.5rem;
      }

      /* Compact trade machine inputs - 2x2 grid */
      .unified-trade-machine {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
        width: 100%;
      }

      .unified-trade-machine > span {
        display: none; /* Hide arrow on mobile */
      }

      .unified-input-group {
        gap: 0.125rem;
      }

      .unified-label {
        font-size: 0.6rem;
      }

      .unified-trade-machine .player-search-input {
        width: 100%;
        padding: 0.5rem 0.75rem;
        font-size: 0.8rem;
      }

      .unified-trade-machine .exclusion-input {
        width: 100% !important;
      }

      /* Generate button spans full width */
      .unified-trade-machine .btn-primary {
        grid-column: 1 / -1;
        padding: 0.625rem;
      }

      /* Compact button row */
      .header-row:last-child {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 0.375rem;
      }

      .header-row .btn {
        padding: 0.5rem 0.25rem;
        font-size: 0.7rem;
        white-space: nowrap;
      }

      .header-row .btn-loop {
        font-size: 0.65rem;
      }

      .header-row .btn-share-loop {
        font-size: 0.6rem;
        padding: 0.5rem 0.2rem;
      }

      .header-row .btn-share-loop[style*="display: none"] + .btn-success {
        grid-column: span 1;
      }

      .header-row .btn-success {
        font-size: 0.65rem;
      }

      .header-row .btn-danger {
        font-size: 0.7rem;
      }

      /* Trade container */
      .trade-container {
        flex-direction: column;
        gap: 0.75rem;
        padding-bottom: 0.5rem;
        width: 100%;
      }

      .team-card, .add-team-card {
        max-width: 100%;
        min-width: auto;
        width: 100%;
        box-sizing: border-box;
      }

      .team-card {
        border-radius: 10px;
      }

      .team-header {
        padding: 0.75rem;
      }

      .team-select {
        font-size: 0.875rem;
      }

      .team-status {
        padding: 0.375rem 0.75rem;
        font-size: 0.65rem;
      }

      .team-body {
        padding: 0.75rem;
        gap: 0.5rem;
        display: flex;
        flex-direction: column;
      }

      /* On mobile, show trade content (Trades/Acquires) before roster */
      .team-body .trade-content {
        order: 1;
      }

      .team-body .roster-section {
        order: 2;
      }

      /* Make roster collapsed by default on mobile */
      .roster-section > *:not(.section-label) {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .roster-section.expanded > *:not(.section-label) {
        max-height: 3000px;
      }

      .roster-section .section-label {
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem 0;
      }

      .roster-section .section-label::after {
        content: '‚ñº Tap to expand';
        font-size: 0.6rem;
        color: var(--text-secondary);
        transition: transform 0.3s ease;
      }

      .roster-section.expanded .section-label::after {
        content: '‚ñ≤ Tap to collapse';
      }

      .add-team-card {
        min-height: 60px;
        padding: 0.75rem;
      }

      .add-team-card span:first-child {
        font-size: 1.25rem;
      }

      .add-team-card span:last-child {
        font-size: 0.75rem;
      }

      /* Player chips */
      .player-chip {
        padding: 0.375rem 0.5rem;
        font-size: 0.75rem;
      }

      .player-headshot {
        width: 28px;
        height: 28px;
      }

      .team-logo {
        width: 22px;
        height: 22px;
      }

      /* Roster items on mobile - stack badges below name if needed */
      .player-roster-item {
        padding: 0.375rem 0.5rem;
        font-size: 0.75rem;
      }

      .player-roster-name {
        flex-wrap: wrap;
        row-gap: 0.15rem;
        font-size: 0.75rem;
      }

      .player-roster-salary {
        font-size: 0.7rem;
      }

      .roster-headshot {
        width: 24px;
        height: 24px;
      }

      /* Smaller badges on mobile */
      .ntc-badge, .restriction-badge, .na-badge, .pp-badge, .min-badge, .tw-badge, .mse-badge, .tk-badge {
        font-size: 0.5rem;
        padding: 0.1rem 0.2rem;
      }

      .injury-badge {
        font-size: 0.55rem;
      }

      /* Section labels */
      .section-label {
        font-size: 0.625rem;
      }

      .section-header {
        padding: 0.375rem 0;
        margin-bottom: 0.375rem;
      }

      .section-header-logo {
        width: 18px;
        height: 18px;
      }

      .section-header-text {
        font-size: 0.7rem;
      }

      /* Trade status */
      .trade-status {
        padding: 0.625rem 0.75rem;
        margin-bottom: 0.75rem;
        border-radius: 10px;
      }

      .trade-status-icon {
        width: 28px;
        height: 28px;
        font-size: 0.875rem;
      }

      .trade-status-title {
        font-size: 0.8rem;
      }

      .trade-status-message {
        font-size: 0.7rem;
      }

      .check-rumors-link {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
      }

      /* Glossary - more compact */
      .glossary-section {
        margin-top: 1rem;
        padding: 1rem;
      }

      .glossary-header h3 {
        font-size: 0.875rem;
      }

      .glossary-grid {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }

      .glossary-item {
        padding: 0.375rem 0.5rem;
      }

      .glossary-description {
        font-size: 0.7rem;
      }

      /* Contact footer */
      .contact-footer {
        margin-top: 1rem;
        padding: 0.75rem;
        font-size: 0.7rem;
      }

      /* Rumors section */
      .rumors-section {
        margin-top: 1rem;
        padding: 1rem;
      }

      .rumors-section-header h3 {
        font-size: 0.9rem;
      }

      .rumor-item {
        padding: 0.625rem 0.75rem;
      }

      .rumor-text {
        font-size: 0.8rem;
      }

      /* Multi-player chips */
      .selected-players-chips,
      .excluded-chips {
        max-width: 100%;
      }

      .selected-player-chip,
      .excluded-chip {
        font-size: 0.65rem;
        padding: 0.2rem 0.4rem;
      }

      /* Modal adjustments */
      .image-modal-content {
        max-width: 95%;
        margin: 1rem;
      }

      .image-modal-header {
        padding: 0.75rem 1rem;
      }

      .image-modal-header h3 {
        font-size: 1rem;
      }

      .format-selector {
        gap: 0.375rem;
      }

      .format-btn {
        width: 32px;
        height: 32px;
        font-size: 0.875rem;
      }

      .image-modal-body {
        padding: 0.75rem;
        max-height: 50vh;
      }

      .image-modal-footer {
        padding: 0.75rem;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .image-modal-footer .btn {
        font-size: 0.75rem;
        padding: 0.5rem 0.75rem;
      }
    }

    /* Even smaller screens */
    @media (max-width: 380px) {
      h1 {
        font-size: 1.1rem;
      }

      .unified-trade-machine {
        grid-template-columns: 1fr;
      }

      .header-row:last-child {
        grid-template-columns: 1fr 1fr;
      }

      .header-row:last-child .btn-danger {
        grid-column: 1 / -1;
      }
    }

    /* Badge Glossary Section */
    .glossary-section {
      margin-top: 2rem;
      padding: 1.5rem;
      background: var(--surface);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .glossary-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    .glossary-header h3 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
      margin: 0;
    }

    .glossary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 0.75rem;
    }

    .glossary-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: var(--bg);
      border-radius: 8px;
    }

    .glossary-badge {
      flex-shrink: 0;
    }

    .glossary-description {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .glossary-description strong {
      color: var(--text);
      font-weight: 600;
    }

    /* Trade Rumors Section Styles */
    .rumors-section {
      margin-top: 2rem;
      padding: 1.5rem;
      background: var(--surface);
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .rumors-section-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .rumors-section-header h3 {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text);
      margin: 0;
    }

    .rumors-section-header .icon {
      font-size: 1.25rem;
    }

    .player-rumors {
      margin-bottom: 1.5rem;
    }

    .player-rumors:last-child {
      margin-bottom: 0;
    }

    .player-rumors-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    .player-rumors-header h4 {
      font-size: 0.9375rem;
      font-weight: 600;
      color: var(--accent);
      margin: 0;
    }

    .player-rumors-header .fallback-note {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .rumors-count-badge {
      background: var(--accent-dim);
      color: var(--accent);
      font-size: 0.6875rem;
      font-weight: 600;
      padding: 0.125rem 0.5rem;
      border-radius: 10px;
      margin-left: auto;
    }

    .rumor-item {
      background: var(--bg);
      border-radius: 8px;
      padding: 0.875rem 1rem;
      margin-bottom: 0.625rem;
      border-left: 3px solid var(--accent);
    }

    .rumor-item:last-child {
      margin-bottom: 0;
    }

    .rumor-meta {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.5rem;
      font-size: 0.75rem;
    }

    .rumor-date {
      color: var(--text-secondary);
    }

    .rumor-outlet {
      color: var(--accent);
    }

    .rumor-text {
      font-size: 0.875rem;
      line-height: 1.5;
      color: var(--text);
    }

    .rumor-text a {
      color: var(--text);
      text-decoration: none;
      border-bottom: 1px dotted var(--border);
    }

    .rumor-text a:hover {
      border-bottom-color: var(--accent);
    }

    .rumors-footer {
      text-align: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .rumors-footer a {
      color: var(--text-secondary);
      font-size: 0.75rem;
      text-decoration: none;
    }

    .rumors-footer a:hover {
      color: var(--accent);
    }

    .rumors-loading {
      text-align: center;
      padding: 2rem;
      color: var(--text-secondary);
    }

    .rumors-loading .spinner {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .no-rumors {
      text-align: center;
      padding: 1.5rem;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .contact-footer {
      margin-top: 2rem;
      padding: 1rem;
      text-align: center;
      font-size: 0.8125rem;
      color: var(--text-secondary);
    }

    .contact-footer a {
      color: var(--accent);
      text-decoration: none;
    }

    .contact-footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üèÄ NBA Trade Machine</h1>
      <div class="header-actions">
        <div class="header-row">
          <div class="trade-machine unified-trade-machine">
            <!-- Player input -->
            <div class="unified-input-group">
              <label class="unified-label">Player</label>
              <div class="multi-player-container">
                <div class="autocomplete-container">
                  <input type="text" id="unifiedPlayerInput" class="player-search-input" placeholder="Any player..." autocomplete="off">
                  <div class="autocomplete-dropdown" id="unifiedPlayerDropdown"></div>
                </div>
                <div class="selected-players-chips" id="unifiedPlayerChips"></div>
              </div>
            </div>
            
            <!-- Origin team input -->
            <div class="unified-input-group">
              <label class="unified-label">From</label>
              <div class="autocomplete-container">
                <input type="text" id="unifiedOriginInput" class="player-search-input" placeholder="Any team..." autocomplete="off">
                <div class="autocomplete-dropdown" id="unifiedOriginDropdown"></div>
              </div>
            </div>
            
            <span style="color: var(--text-secondary); font-size: 1.25rem;">‚Üí</span>
            
            <!-- Destination team input -->
            <div class="unified-input-group">
              <label class="unified-label">To</label>
              <div class="autocomplete-container">
                <input type="text" id="unifiedDestInput" class="player-search-input" placeholder="Any team..." autocomplete="off">
                <div class="autocomplete-dropdown" id="unifiedDestDropdown"></div>
              </div>
            </div>
            
            <!-- Exclude players -->
            <div class="unified-input-group">
              <label class="unified-label">Exclude</label>
              <div class="exclusion-container">
                <div class="autocomplete-container">
                  <input type="text" id="excludePlayersInput" class="player-search-input exclusion-input" placeholder="Exclude..." autocomplete="off">
                  <div class="autocomplete-dropdown" id="excludePlayersDropdown"></div>
                </div>
                <div class="excluded-chips" id="excludedChips"></div>
              </div>
            </div>
            
            <!-- Generate button -->
            <button class="btn btn-primary" id="generateTradeBtn">üé≤ Generate</button>
          </div>
        </div>
        <div class="header-row">
          <button class="btn btn-loop" id="loopTradeBtn" title="Auto-generate new trade every 8 seconds">‚ñ∂ Trade Loop</button>
          <button class="btn btn-share-loop" id="shareLoopBtn" title="Copy link to share this trade loop" style="display: none;">üîó Share Loop</button>
          <button class="btn btn-success" id="generateImageBtn">üì∏ Generate Image</button>
          <button class="btn btn-danger" id="resetBtn">Reset Trade</button>
        </div>
      </div>
    </header>

    <!-- Hidden canvas for image generation -->
    <canvas id="tradeCanvas" style="display: none;"></canvas>
    
    <!-- Modal for showing generated image -->
    <div id="imageModal" class="image-modal" style="display: none;">
      <div class="image-modal-content">
        <div class="image-modal-header">
          <h3>Trade Image</h3>
          <div class="format-selector">
            <button class="format-btn active" data-format="twitter" title="Twitter/X (16:9)">ùïè</button>
            <button class="format-btn" data-format="instagram" title="Instagram (1:1)">‚óª</button>
            <button class="format-btn" data-format="stories" title="Stories (9:16)">‚ñØ</button>
          </div>
          <button class="image-modal-close" id="closeImageModal">√ó</button>
        </div>
        <div class="image-modal-body">
          <img id="generatedImage" alt="Generated Trade Image">
        </div>
        <div class="image-modal-footer">
          <button class="btn btn-primary" id="downloadImageBtn">‚¨áÔ∏è Download Image</button>
          <button class="btn btn-secondary" id="copyImageBtn">üìã Copy to Clipboard</button>
        </div>
      </div>
    </div>

    <div class="loading" id="loadingState" style="display: none;">
      <div class="spinner"></div>
      <p>Loading player data...</p>
    </div>

    <div id="mainContent">
      <div class="trade-status" id="tradeStatus" style="display: none;">
        <div class="trade-status-icon" id="tradeStatusIcon">‚úì</div>
        <div class="trade-status-text">
          <div class="trade-status-title" id="tradeStatusTitle">Trade is valid</div>
          <div class="trade-status-message" id="tradeStatusMessage"></div>
        </div>
        <a href="#tradeRumorsContainer" class="check-rumors-link" id="checkRumorsLink" style="display: none;">üì∞ Check Rumors</a>
      </div>

      <div class="trade-container" id="tradeContainer">
        <!-- Skeleton loading cards -->
        <div class="trade-card skeleton-card" style="opacity: 0.6;">
          <div class="team-header">
            <select class="team-select" disabled><option>Loading teams...</option></select>
          </div>
          <div class="trade-content" style="min-height: 200px; display: flex; align-items: center; justify-content: center; color: #94a3b8;">
            Loading player data...
          </div>
        </div>
        <div class="trade-card skeleton-card" style="opacity: 0.6;">
          <div class="team-header">
            <select class="team-select" disabled><option>Loading teams...</option></select>
          </div>
          <div class="trade-content" style="min-height: 200px; display: flex; align-items: center; justify-content: center; color: #94a3b8;">
            Loading player data...
          </div>
        </div>
      </div>
      
      <!-- Badge Glossary Section -->
      <div class="glossary-section">
        <div class="glossary-header">
          <span>üìñ</span>
          <h3>Badge Glossary</h3>
        </div>
        <div class="glossary-grid">
          <div class="glossary-item">
            <span class="glossary-badge"><span class="tw-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">TW</span></span>
            <span class="glossary-description"><strong>Two-Way Contract</strong> ‚Äî Counts as $0 in trades</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="tw-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: rgba(239, 68, 68, 0.15); color: #ef4444;">10D</span></span>
            <span class="glossary-description"><strong>10-Day Contract</strong> ‚Äî Cannot be traded</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="ntc-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">NTC</span></span>
            <span class="glossary-description"><strong>No-Trade Clause</strong> ‚Äî Player can veto trades</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="na-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">NA</span></span>
            <span class="glossary-description"><strong>Not Aggregated</strong> ‚Äî Can't be packaged with other salaries</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="pp-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">PP</span></span>
            <span class="glossary-description"><strong>Poison Pill</strong> ‚Äî Incoming value is average of current-year salary and the annual salary in each year of extension</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="tk-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">TK</span></span>
            <span class="glossary-description"><strong>Trade Kicker</strong> ‚Äî Player gets bonus % on trade</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="mse-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">MSE</span></span>
            <span class="glossary-description"><strong>Min Salary Exception</strong> ‚Äî No salary matching needed</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="min-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">MIN</span></span>
            <span class="glossary-description"><strong>Minimum Salary</strong></span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="restriction-badge" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600;">!</span></span>
            <span class="glossary-description"><strong>Trade Restriction</strong> ‚Äî Date restriction before trade</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="injury-badge" style="padding: 0 0.15rem; border-radius: 2px; font-size: 0.65rem; font-weight: 700; color: #ff0000; background: white; border: 1.5px solid #ff0000;">‚úö</span></span>
            <span class="glossary-description"><strong>Inactive</strong> ‚Äî Player is currently out</span>
          </div>
          <div class="glossary-item">
            <span class="glossary-badge"><span class="pick-conditional" style="padding: 0.125rem 0.4rem; border-radius: 4px; font-size: 0.65rem; font-weight: 600; background: rgba(251, 146, 60, 0.2); color: #ea580c;">COND</span></span>
            <span class="glossary-description"><strong>Conditional Pick</strong> ‚Äî Pick has conditions</span>
          </div>
        </div>
      </div>
      
      <!-- Trade Rumors Section -->
      <div id="tradeRumorsContainer"></div>
      
      <!-- Contact Footer -->
      <div class="contact-footer">
        Anything wrong? Contact us at <a href="/cdn-cgi/l/email-protection#cda5a2a2bdbea5b4bda88da5a2a2bdbea5b4bda8e3aea2a0f2aeaef0aca9a8bfa2ac8da5a2a2bdbea5b4bda8e3aea2a0"><span class="__cf_email__" data-cfemail="11797e7e61627968617451797e7e6162796861743f727e7c">[email&#160;protected]</span></a>
      </div>
    </div>
  </div>

  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script>
    // Capture URL params immediately before anything can modify them
    const INITIAL_URL_PARAMS = new URLSearchParams(window.location.search);
    const IS_LOOP_URL = INITIAL_URL_PARAMS.has('loop') || INITIAL_URL_PARAMS.has('player') || 
                        (INITIAL_URL_PARAMS.has('from') && !INITIAL_URL_PARAMS.has('players')) || 
                        (INITIAL_URL_PARAMS.has('to') && !INITIAL_URL_PARAMS.has('players')) ||
                        INITIAL_URL_PARAMS.has('exclude');
    
    // Check if data was injected by Cloudflare Worker
    let csvFetchPromise;
    if (window.__INJECTED_CSV_DATA__) {
      const csvText = decodeURIComponent(escape(atob(window.__INJECTED_CSV_DATA__)));
      csvFetchPromise = Promise.resolve(csvText);
    } else {
      // Fallback - this will fail on GitHub Pages (redirects to Cloudflare anyway)
      csvFetchPromise = Promise.reject('No data');
    }
    
    // Start fetching rumors in parallel (for initial trade display)
    const INITIAL_RUMORS_URL = 'https://hoopshype-rumors-api.thejorgesierra.workers.dev/api/rumors/latest';
    let initialRumorsData = null;
    const rumorsFetchPromise = fetch(INITIAL_RUMORS_URL)
      .then(r => r.ok ? r.json() : [])
      .then(data => { initialRumorsData = data; return data; })
      .catch(() => []);
    
    // Start fetching trade stats in parallel
    const tradeStatsFetchPromise = fetch('/api/trade-stats?period=24h')
      .then(r => r.ok ? r.json() : { totalTrades: 0, players: {} })
      .catch(() => ({ totalTrades: 0, players: {} }));
    
    // ========== TRADE VALUE INTEGRATION (hidden feature for realistic random trades) ==========
    const TV_SHEET_ID = '2PACX-1vSg6im6IYB6HXMGzQbmmBnLw9SfQLzxCSo8OfChxlJLhsB6BBCO0wPF_TMch0YgAbtFqYkwDWrsxRe7';
    const TV_GID = '1310971167';
    const TV_CSV_URL = `https://docs.google.com/spreadsheets/d/e/${TV_SHEET_ID}/pub?gid=${TV_GID}&single=true&output=csv`;
    let tradeValueMap = new Map(); // playerName -> uncappedTV
    
    // Fetch and compute trade values in background
    console.log('üèÄ TRADE VALUE INTEGRATION: Starting fetch...');
    const tradeValueFetchPromise = fetch(TV_CSV_URL)
      .then(r => {
        console.log(`üèÄ Trade value fetch status: ${r.status}`);
        return r.ok ? r.text() : null;
      })
      .then(csvText => {
        if (!csvText) {
          console.log('Trade value fetch returned empty');
          return;
        }
        console.log(`Trade value CSV length: ${csvText.length} chars`);
        tradeValueMap = computeTradeValues(csvText);
        console.log(`Trade values computed: ${tradeValueMap.size} players, lowercase map: ${tradeValueMapLower.size}`);
        // Debug: check known players
        const wembyTV = getTradeValue('Victor Wembanyama');
        const flaggTV = getTradeValue('Cooper Flagg');
        const giannisTV = getTradeValue('Giannis Antetokounmpo');
        console.log(`Wembanyama TV: $${wembyTV?.toLocaleString() || 'NOT FOUND'}`);
        console.log(`Cooper Flagg TV: $${flaggTV?.toLocaleString() || 'NOT FOUND'} (should include potential bonus)`);
        console.log(`Giannis TV: $${giannisTV?.toLocaleString() || 'NOT FOUND'} (no potential bonus - over 25)`);
      })
      .catch(err => {
        console.error('Trade value fetch failed:', err);
      });
    
    // Case-insensitive trade value lookup
    let tradeValueMapLower = new Map(); // lowercase name -> trade value
    function getTradeValue(playerName) {
      return tradeValueMapLower.get(playerName.toLowerCase().trim());
    }
    
    // Compact trade value computation (mirrors Trade Value Rankings formula)
    function computeTradeValues(csvText) {
      console.log('üèÄ computeTradeValues called, CSV length:', csvText.length);
      const rows = parseTradeValueCSV(csvText);
      console.log('üèÄ Parsed rows:', rows.length);
      const roster = [], historical = [];
      let todayStr = null;
      
      for (const row of rows.slice(1)) {
        while (row.length < 22) row.push(''); // Extend to include column U (index 20)
        if (row[18] && !todayStr) todayStr = row[18];
        if (row[0] && row[1]) {
          const draftVal = row[20];
          const draftPick = parseInt(draftVal) || null;
          roster.push({
            player: row[1].trim(),
            rat365: parseFloat(row[2]) || 0,
            salary: parseInt(row[3].replace(/[$,]/g, '')) || 0,
            birthday: row[4] || '',
            draftPick: draftPick // Column U = draft position (1-60)
          });
          // Debug first few players' draft info
          if (roster.length <= 5) {
            console.log(`Player ${row[1]}: draft col raw="${draftVal}", parsed=${draftPick}`);
          }
        }
        if (row[6] && row[7]) {
          const g = parseInt(row[9]) || 0;
          if (g > 0) historical.push({
            year: row[6], player: row[7].trim(),
            totalRat: parseFloat(row[8].replace(/,/g, '')) || 0, games: g
          });
        }
      }
      
      // Build historical lookup (case-insensitive)
      console.log(`üèÄ Roster parsed: ${roster.length} players, first 3 draft picks:`, 
        roster.slice(0,3).map(p => `${p.player}:${p.draftPick}`));
      const playerHist = {};
      for (const h of historical) {
        const k = h.player.toLowerCase();
        if (!playerHist[k]) playerHist[k] = [];
        playerHist[k].push(h);
      }
      
      const WEIGHTS = {'2025-26':1.0,'2024-25':0.6,'2023-24':0.36,'2022-23':0.216,'2021-22':0.1296};
      const EXPECTED = {'2021-22':82,'2022-23':82,'2023-24':82,'2024-25':82,'2025-26':48};
      const EXP = 1.8, BETA = 0.8, MAX_MULT = 1.4, MIN_PCT = 0.40;
      const WM_W = 0.85, RAT_W = 0.15, AGE_BONUS = 1.0, OLD_TH = 35, OLD_PEN = 0.03;
      
      // Compute watermark for each player
      for (const p of roster) {
        const hist = playerHist[p.player.toLowerCase()] || [];
        let num = 0, den = 0;
        for (const h of hist) {
          const w = WEIGHTS[h.year] || 0;
          if (w <= 0 || h.games <= 0) continue;
          let perGame = h.totalRat / h.games;
          const exp = EXPECTED[h.year] || 82;
          if (h.games / exp >= MIN_PCT) perGame *= Math.min(MAX_MULT, Math.pow(exp / h.games, BETA));
          num += perGame * w * h.games;
          den += w * h.games;
        }
        p.watermark = den > 0 ? num / den : 0;
        
        // Games-corrected RAT365
        const cur = hist.filter(h => h.year === '2025-26');
        const curGames = cur.reduce((s,h) => s + h.games, 0);
        if (curGames > 0 && curGames / 48 >= MIN_PCT) {
          p.rat365adj = p.rat365 * Math.min(MAX_MULT, Math.pow(48 / curGames, BETA));
        } else {
          p.rat365adj = p.rat365;
        }
      }
      
      // Age calculation
      const parseDate = s => {
        if (!s) return null;
        const parts = s.split('/');
        return parts.length === 3 ? new Date(+parts[2], +parts[0]-1, +parts[1]) : null;
      };
      const today = parseDate(todayStr) || new Date();
      const ages = [];
      for (const p of roster) {
        const bd = parseDate(p.birthday);
        p.age = bd ? (today - bd) / (365.25 * 24 * 60 * 60 * 1000) : null;
        if (p.age) ages.push(p.age);
      }
      const avgAge = ages.length > 0 ? ages.reduce((a,b) => a+b, 0) / ages.length : 26;
      const maxDev = avgAge - Math.min(...ages);
      
      for (const p of roster) {
        if (p.age !== null && p.age < avgAge) {
          p.ageMult = 1.0 + AGE_BONUS * (avgAge - p.age) / maxDev;
        } else if (p.age !== null && p.age >= OLD_TH) {
          p.ageMult = Math.max(0.5, 1.0 - OLD_PEN * (p.age - OLD_TH));
        } else {
          p.ageMult = 1.0;
        }
      }
      
      // Trade value calculation
      const totalSalPool = roster.reduce((s,p) => s + p.salary, 0);
      const totalWM = roster.reduce((s,p) => s + Math.pow(Math.max(p.watermark,0), EXP), 0);
      const totalRAT = roster.reduce((s,p) => s + Math.pow(Math.max(p.rat365adj,0), EXP), 0);
      
      for (const p of roster) {
        const tvWM = totalWM > 0 ? (Math.pow(Math.max(p.watermark,0), EXP) / totalWM) * totalSalPool : 0;
        const tvRAT = totalRAT > 0 ? (Math.pow(Math.max(p.rat365adj,0), EXP) / totalRAT) * totalSalPool : 0;
        p.tvPreAge = WM_W * tvWM + RAT_W * tvRAT;
        p.tvWithAge = p.tvPreAge * p.ageMult;
      }
      
      const totalWithAge = roster.reduce((s,p) => s + p.tvWithAge, 0);
      
      // Potential bonus constants for young players
      const POTENTIAL_MAX = 7000000; // $7M maximum potential bonus
      const MIN_ROOKIE_AGE = 18 + 300/365; // 18 years 300 days (youngest realistic debut age)
      const MAX_POTENTIAL_AGE = 25; // No potential bonus after 25
      const DRAFT_DECAY = 0.05; // Exponential decay rate for draft position
      const AGE_DECAY = 0.5; // Exponential decay rate for age
      
      // Calculate potential bonus for young players
      function calcPotentialBonus(age, draftPick) {
        // Only for players under 25 with valid draft position
        if (age === null || age >= MAX_POTENTIAL_AGE || !draftPick || draftPick < 1 || draftPick > 60) {
          return 0;
        }
        
        // Draft position factor: exponential decay (pick 1 = 1.0, pick 60 ‚âà 0.05)
        // Bigger gap between pick 1-2 than between pick 59-60
        const draftFactor = Math.exp(-DRAFT_DECAY * (draftPick - 1));
        
        // Age factor: exponential decay (18.82 years = 1.0, 25 years ‚âà 0.04)
        // Bigger gap for younger players
        const ageFromMin = Math.max(0, age - MIN_ROOKIE_AGE);
        const ageFactor = Math.exp(-AGE_DECAY * ageFromMin);
        
        return Math.round(POTENTIAL_MAX * draftFactor * ageFactor);
      }
      
      const result = new Map();
      let debugCount = 0;
      
      // Find Cooper Flagg specifically for debugging
      const flagg = roster.find(p => p.player.toLowerCase().includes('flagg'));
      if (flagg) {
        console.log('üö© FLAGG FOUND:', JSON.stringify(flagg));
      } else {
        console.log('üö© FLAGG NOT FOUND in roster');
      }
      
      for (const p of roster) {
        const baseTV = totalWithAge > 0 ? Math.round((p.tvWithAge / totalWithAge) * totalSalPool) : 0;
        const potentialBonus = calcPotentialBonus(p.age, p.draftPick);
        const tv = baseTV + potentialBonus;
        result.set(p.player, tv);
        tradeValueMapLower.set(p.player.toLowerCase().trim(), tv);
        
        // Debug young players with draft picks
        if (p.age !== null && p.age < 25 && debugCount < 10) {
          console.log(`üåü POTENTIAL BONUS: ${p.player}, age=${p.age?.toFixed(2)}, draft=${p.draftPick}, baseTV=$${baseTV.toLocaleString()}, bonus=$${potentialBonus.toLocaleString()}, totalTV=$${tv.toLocaleString()}`);
          debugCount++;
        }
      }
      return result;
    }
    
    function parseTradeValueCSV(text) {
      const rows = []; let current = '', inQuotes = false, row = [];
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (inQuotes) {
          if (ch === '"' && text[i+1] === '"') { current += '"'; i++; }
          else if (ch === '"') inQuotes = false;
          else current += ch;
        } else {
          if (ch === '"') inQuotes = true;
          else if (ch === ',') { row.push(current.trim()); current = ''; }
          else if (ch === '\n' || ch === '\r') {
            if (ch === '\r' && text[i+1] === '\n') i++;
            row.push(current.trim());
            if (row.length > 1 || row[0] !== '') rows.push(row);
            row = []; current = '';
          } else current += ch;
        }
      }
      if (current || row.length > 0) { row.push(current.trim()); if (row.length > 1 || row[0] !== '') rows.push(row); }
      return rows;
    }
    
    // Check if trade values are balanced (with dynamic tolerance for stars)
    // Draft pick values: $15M for 1st round, $5M for 2nd round
    const FIRST_ROUND_PICK_TV = 15000000;
    const SECOND_ROUND_PICK_TV = 5000000;
    
    function getPickTradeValue(pick) {
      return pick.round === '1st' ? FIRST_ROUND_PICK_TV : SECOND_ROUND_PICK_TV;
    }
    
    function isTradeValueBalanced(testTrade, baseTolerance = 0.50) {
      if (tradeValueMapLower.size === 0) {
        return true; // Skip check if no data
      }
      
      // Calculate total trade value each team is sending out (players + picks)
      const teamTVs = testTrade.map((t, idx) => {
        // Player trade values
        const playerTV = t.playersOut.reduce((sum, p) => {
          const pTV = getTradeValue(p.player);
          const used = pTV || p.salary;
          return sum + used;
        }, 0);
        
        // Pick trade values
        const pickTV = (t.picksOut || []).reduce((sum, pick) => {
          return sum + getPickTradeValue(pick);
        }, 0);
        
        return playerTV + pickTV;
      });
      
      // Dynamic tolerance based on total trade value
      // High-value trades (stars) get more flexibility because their TV far exceeds salary
      const maxTV = Math.max(...teamTVs);
      let tolerance = baseTolerance;
      if (maxTV > 80000000) tolerance = 0.70;      // $80M+ trades: 70% tolerance (only need 30% match)
      else if (maxTV > 50000000) tolerance = 0.60; // $50M+ trades: 60% tolerance
      else if (maxTV > 30000000) tolerance = 0.55; // $30M+ trades: 55% tolerance
      
      // For 2-team trades: compare directly
      if (testTrade.length === 2) {
        const [tv1, tv2] = teamTVs;
        if (tv1 === 0 || tv2 === 0) return true;
        const ratio = Math.min(tv1, tv2) / Math.max(tv1, tv2);
        const balanced = ratio >= (1 - tolerance);
        return balanced;
      } else {
        // For 3+ team trades: very lenient - just check no team loses > 80%
        // Multi-team trades naturally spread value around
        for (let i = 0; i < testTrade.length; i++) {
          const outTV = teamTVs[i];
          // Include incoming picks in the calculation
          const inTV = testTrade[i].playersIn.reduce((sum, p) => {
            const tv = getTradeValue(p.player) || p.salary;
            return sum + tv;
          }, 0) + testTrade.reduce((sum, otherTeam, otherIdx) => {
            // Add incoming picks from other teams
            if (otherIdx === i) return sum;
            return sum + (otherTeam.picksOut || [])
              .filter(pick => pick.destination === i)
              .reduce((pickSum, pick) => pickSum + getPickTradeValue(pick), 0);
          }, 0);
          
          if (outTV === 0 && inTV === 0) continue;
          if (outTV === 0 || inTV === 0) continue; // Allow if one side is 0 in multi-team
          const ratio = Math.min(outTV, inTV) / Math.max(outTV, inTV);
          if (ratio < 0.20) { // Very lenient for 3+ team trades
            return false;
          }
        }
        return true;
      }
    }
    
    // Get available picks for random trades (only non-conditional picks)
    // Returns picks that can be safely traded without violating Stepien Rule
    function getAvailablePicksForRandomTrade(teamName, existingPicksOut = []) {
      // Get all picks owned by this team
      const teamPicks = draftPicks
        .map((pick, idx) => ({ ...pick, pickIndex: idx }))
        .filter(p => p.team === teamName);
      
      // Only consider non-conditional (sure) picks for random trades
      const surePicks = teamPicks.filter(p => p.surePick === 'YES');
      
      // Separate by round
      const firstRoundPicks = surePicks.filter(p => p.round === '1st');
      const secondRoundPicks = surePicks.filter(p => p.round === '2nd');
      
      // For first round picks, check Stepien Rule
      // We need to ensure no consecutive years are left without a first round pick
      const years = [2026, 2027, 2028, 2029, 2030, 2031];
      const alreadyTradingYears = existingPicksOut
        .filter(p => p.round === '1st')
        .map(p => parseInt(p.year));
      
      const availableFirstRound = [];
      
      for (const pick of firstRoundPicks) {
        const pickYear = parseInt(pick.year);
        
        // Skip if already trading this year
        if (alreadyTradingYears.includes(pickYear)) continue;
        
        // Check if trading this pick would leave consecutive years empty
        const yearsAfterTrade = [...alreadyTradingYears, pickYear];
        
        // Get remaining first round picks after this hypothetical trade
        const remainingFirstRound = firstRoundPicks
          .filter(p => !yearsAfterTrade.includes(parseInt(p.year)))
          .map(p => parseInt(p.year));
        
        // Check consecutive years
        let violatesStepien = false;
        for (let i = 0; i < years.length - 1; i++) {
          const year1 = years[i];
          const year2 = years[i + 1];
          if (!remainingFirstRound.includes(year1) && !remainingFirstRound.includes(year2)) {
            violatesStepien = true;
            break;
          }
        }
        
        if (!violatesStepien) {
          availableFirstRound.push(pick);
        }
      }
      
      return {
        firstRound: availableFirstRound,
        secondRound: secondRoundPicks
      };
    }
    
    // Add random picks to a trade for star players
    function addPicksToTrade(testTrade, teamIndex, destination, isSuperstar) {
      const teamName = testTrade[teamIndex].teamName;
      const existingPicksOut = testTrade[teamIndex].picksOut || [];
      
      const availablePicks = getAvailablePicksForRandomTrade(teamName, existingPicksOut);
      
      // Determine how many picks to add (more for superstars)
      const maxFirstRound = isSuperstar ? 2 : 1;
      const maxSecondRound = isSuperstar ? 2 : 1;
      
      // Randomly select first round picks
      const shuffledFirst = [...availablePicks.firstRound].sort(() => Math.random() - 0.5);
      const firstToAdd = shuffledFirst.slice(0, Math.floor(Math.random() * (maxFirstRound + 1)));
      
      // Randomly select second round picks
      const shuffledSecond = [...availablePicks.secondRound].sort(() => Math.random() - 0.5);
      const secondToAdd = shuffledSecond.slice(0, Math.floor(Math.random() * (maxSecondRound + 1)));
      
      // Add picks to the trade
      const picksToAdd = [...firstToAdd, ...secondToAdd].map(pick => ({
        team: pick.team,
        year: pick.year,
        round: pick.round,
        notes: pick.notes || '',
        pickIndex: pick.pickIndex,
        surePick: pick.surePick,
        linkedTo: pick.linkedTo || '',
        destination: destination
      }));
      
      if (!testTrade[teamIndex].picksOut) {
        testTrade[teamIndex].picksOut = [];
      }
      testTrade[teamIndex].picksOut.push(...picksToAdd);
      
      return picksToAdd.length;
    }
    // ========== END TRADE VALUE INTEGRATION ==========
    
    const MAX_TEAMS = 5;

    let players = [];
    let teams = [];
    let tradeExceptions = []; // Array of { team, value, expirationDate }
    let draftPicks = []; // Array of { team, round, year, surePick, notes, linkedTo }
    let draftRights = []; // Array of { team, playerName, draftedYear }
    let tradeTeams = []; // Array of { teamName, playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }

    // Team nicknames for search
    // Team popularity weights for initial random selection
    const teamWeights = {
      'LA Lakers': 25,
      'Golden State': 18,
      'Boston': 12,
      'New York': 10,
      'Chicago': 8,
      'Miami': 7,
      'Dallas': 7,
      'Philadelphia': 7,
      'Denver': 7,
      'Milwaukee': 7,
      'Oklahoma City': 6,
      'Phoenix': 6,
      'LA Clippers': 6,
      'Cleveland': 6,
      'Orlando': 5,
      'Detroit': 5,
      'Houston': 5,
      'Toronto': 5,
      'Atlanta': 5,
      'Sacramento': 5,
      'Minnesota': 4,
      'San Antonio': 4,
      'Brooklyn': 4,
      'Portland': 4,
      'New Orleans': 4,
      'Memphis': 4,
      'Indiana': 4,
      'Washington': 4,
      'Utah': 4,
      'Charlotte': 2
    };

    // Select a random team using weighted probabilities
    function selectWeightedTeam(availableTeams) {
      // Build weighted array for available teams
      let totalWeight = 0;
      const weightedTeams = availableTeams.map(team => {
        // Find matching weight (team names in data may have full city names)
        let weight = 1; // default weight
        for (const [key, w] of Object.entries(teamWeights)) {
          if (team.includes(key)) {
            weight = w;
            break;
          }
        }
        totalWeight += weight;
        return { team, weight };
      });
      
      // Random selection based on weight
      let random = Math.random() * totalWeight;
      for (const { team, weight } of weightedTeams) {
        random -= weight;
        if (random <= 0) return team;
      }
      return availableTeams[0]; // fallback
    }

    // Select two different teams using weighted probabilities
    function selectTwoWeightedTeams(availableTeams) {
      const team1 = selectWeightedTeam(availableTeams);
      const remainingTeams = availableTeams.filter(t => t !== team1);
      const team2 = selectWeightedTeam(remainingTeams);
      return [team1, team2];
    }

    const teamNicknames = {
      'Atlanta': ['Hawks'],
      'Boston': ['Celtics'],
      'Brooklyn': ['Nets'],
      'Charlotte': ['Hornets'],
      'Chicago': ['Bulls'],
      'Cleveland': ['Cavaliers', 'Cavs'],
      'Dallas': ['Mavericks', 'Mavs'],
      'Denver': ['Nuggets'],
      'Detroit': ['Pistons'],
      'Golden State': ['Warriors', 'Dubs', 'GSW'],
      'Houston': ['Rockets'],
      'Indiana': ['Pacers'],
      'LA Clippers': ['Clippers', 'LAC'],
      'LA Lakers': ['Lakers', 'LAL'],
      'Memphis': ['Grizzlies', 'Grizz'],
      'Miami': ['Heat'],
      'Milwaukee': ['Bucks'],
      'Minnesota': ['Timberwolves', 'Wolves', 'T-Wolves'],
      'New Orleans': ['Pelicans', 'Pels'],
      'New York': ['Knicks', 'NYK'],
      'Oklahoma City': ['Thunder', 'OKC'],
      'Orlando': ['Magic'],
      'Philadelphia': ['76ers', 'Sixers', 'Philly'],
      'Phoenix': ['Suns'],
      'Portland': ['Trail Blazers', 'Blazers'],
      'Sacramento': ['Kings'],
      'San Antonio': ['Spurs'],
      'Toronto': ['Raptors'],
      'Utah': ['Jazz'],
      'Washington': ['Wizards']
    };
    
    // Team abbreviations for compact URLs
    const teamAbbreviations = {
      'Atlanta': 'ATL',
      'Boston': 'BOS',
      'Brooklyn': 'BKN',
      'Charlotte': 'CHA',
      'Chicago': 'CHI',
      'Cleveland': 'CLE',
      'Dallas': 'DAL',
      'Denver': 'DEN',
      'Detroit': 'DET',
      'Golden State': 'GSW',
      'Houston': 'HOU',
      'Indiana': 'IND',
      'LA Clippers': 'LAC',
      'LA Lakers': 'LAL',
      'Memphis': 'MEM',
      'Miami': 'MIA',
      'Milwaukee': 'MIL',
      'Minnesota': 'MIN',
      'New Orleans': 'NOP',
      'New York': 'NYK',
      'Oklahoma City': 'OKC',
      'Orlando': 'ORL',
      'Philadelphia': 'PHI',
      'Phoenix': 'PHX',
      'Portland': 'POR',
      'Sacramento': 'SAC',
      'San Antonio': 'SAS',
      'Toronto': 'TOR',
      'Utah': 'UTA',
      'Washington': 'WAS'
    };
    
    // Reverse lookup: abbreviation to team name
    const abbrevToTeam = Object.fromEntries(
      Object.entries(teamAbbreviations).map(([name, abbr]) => [abbr, name])
    );
    
    // Teams with plural names (use "Trade" instead of "Trades")
    const pluralTeamNames = ['LA Lakers', 'LA Clippers'];
    const isTeamPlural = (teamName) => pluralTeamNames.includes(teamName);
    
    // Player trade counter - tracks how many times each player has been added to trades
    const TRADE_COUNTER_KEY = 'playerTradeCounter';
    
    // Global trade stats from API
    let globalTradeStats = { totalTrades: 0, players: {} };
    let lastTrackedTradeHash = ''; // To avoid tracking same trade multiple times
    
    // Try to load cached trade stats immediately
    try {
      const cachedStats = localStorage.getItem('tradeStatsCache');
      if (cachedStats) {
        const { data, timestamp } = JSON.parse(cachedStats);
        // Use cache if less than 5 minutes old
        if (Date.now() - timestamp < 5 * 60 * 1000) {
          globalTradeStats = data;
        }
      }
    } catch (e) {}
    
    // Fetch global trade stats from API
    let tradeStatsLoaded = false;
    async function fetchTradeStats(usePreloaded = false) {
      try {
        if (usePreloaded && !tradeStatsLoaded) {
          // Use the pre-started fetch on first call
          globalTradeStats = await tradeStatsFetchPromise;
          tradeStatsLoaded = true;
        } else {
          // Fresh fetch for subsequent calls
          const response = await fetch('/api/trade-stats?period=24h');
          if (response.ok) {
            globalTradeStats = await response.json();
          }
        }
        // Cache the stats
        try {
          localStorage.setItem('tradeStatsCache', JSON.stringify({
            data: globalTradeStats,
            timestamp: Date.now()
          }));
        } catch (e) {}
      } catch (e) {
        // Silently fail - trade stats are optional
      }
    }
    
    // Track a completed trade
    async function trackCompletedTrade(playerIds) {
      try {
        // Create a hash of the trade to avoid tracking duplicates
        const sortedIds = [...playerIds].sort().join(',');
        if (sortedIds === lastTrackedTradeHash) {
          console.log('[Trade Tracking] Skipped - duplicate trade');
          return;
        }
        lastTrackedTradeHash = sortedIds;
        
        console.log('[Trade Tracking] Tracking trade with', playerIds.length, 'players:', playerIds);
        
        const response = await fetch('/api/track-trade', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ playerIds })
        });
        
        const result = await response.json();
        console.log('[Trade Tracking] Result:', result);
        
        // Update local stats optimistically
        globalTradeStats.totalTrades++;
        playerIds.forEach(id => {
          if (!globalTradeStats.players[id]) {
            globalTradeStats.players[id] = { count: 0, percentage: '0.0' };
          }
          globalTradeStats.players[id].count++;
          globalTradeStats.players[id].percentage = 
            ((globalTradeStats.players[id].count / globalTradeStats.totalTrades) * 100).toFixed(1);
        });
      } catch (e) {
        console.log('[Trade Tracking] Error:', e);
      }
    }
    
    // Get trade percentage for a player
    function getPlayerTradePercentage(playerId) {
      const stats = globalTradeStats.players[playerId];
      return stats ? parseFloat(stats.percentage) : 0;
    }
    
    function getPlayerTradeCounts() {
      try {
        const stored = localStorage.getItem(TRADE_COUNTER_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        return {};
      }
    }
    
    function incrementPlayerTradeCount(playerId, playerName) {
      try {
        const counts = getPlayerTradeCounts();
        const key = playerId || playerName; // Use playerId if available, else name
        counts[key] = (counts[key] || 0) + 1;
        localStorage.setItem(TRADE_COUNTER_KEY, JSON.stringify(counts));
        return counts[key];
      } catch (e) {
        return 0;
      }
    }
    
    function getPlayerTradeCount(playerId, playerName) {
      const counts = getPlayerTradeCounts();
      return counts[playerId] || counts[playerName] || 0;
    }
    
    function resetPlayerTradeCounts() {
      try {
        localStorage.removeItem(TRADE_COUNTER_KEY);
      } catch (e) {}
    }

    // Function to search teams by name or nickname
    function searchTeams(searchTerm) {
      const term = searchTerm.toLowerCase();
      return teams.filter(t => {
        // Check if team name matches
        if (t.toLowerCase().includes(term)) return true;
        // Check if any nickname matches
        for (const [city, nicknames] of Object.entries(teamNicknames)) {
          if (t.includes(city)) {
            if (nicknames.some(nick => nick.toLowerCase().includes(term))) {
              return true;
            }
          }
        }
        return false;
      });
    }

    // DOM Elements
    const loadingState = document.getElementById('loadingState');
    const mainContent = document.getElementById('mainContent');
    const tradeContainer = document.getElementById('tradeContainer');
    const tradeStatus = document.getElementById('tradeStatus');
    const resetBtn = document.getElementById('resetBtn');

    // Parse salary string to number
    function parseSalary(salaryStr) {
      if (!salaryStr || salaryStr === '') return 0;
      return parseFloat(salaryStr.toString().replace(/[$,]/g, '')) || 0;
    }

    // Format number as currency
    function formatSalary(num) {
      if (num === 0) return '$0';
      const absNum = Math.abs(num);
      const formatted = '$' + absNum.toLocaleString('en-US', { maximumFractionDigits: 0 });
      return num < 0 ? '-' + formatted : formatted;
    }

    // Color gradient for age (younger = green, older = red)
    // Age range: 19-40, with 25 being neutral yellow
    function getAgeColor(age) {
      if (!age) return '#6b7280'; // gray for N/A
      // Parse years from "23-321" format or just "23"
      const years = parseInt(age.toString().split('-')[0]) || 0;
      if (years <= 0) return '#6b7280';
      
      const minAge = 19;
      const maxAge = 38;
      const clampedAge = Math.max(minAge, Math.min(maxAge, years));
      const ratio = (clampedAge - minAge) / (maxAge - minAge);
      
      // Green (young) -> Yellow (mid) -> Red (old)
      if (ratio <= 0.5) {
        // Green to Yellow
        const r = Math.round(34 + (234 - 34) * (ratio * 2));
        const g = Math.round(197 - (197 - 179) * (ratio * 2));
        const b = Math.round(94 - (94 - 8) * (ratio * 2));
        return `rgb(${r}, ${g}, ${b})`;
      } else {
        // Yellow to Red
        const r = Math.round(234 + (239 - 234) * ((ratio - 0.5) * 2));
        const g = Math.round(179 - (179 - 68) * ((ratio - 0.5) * 2));
        const b = Math.round(8 + (68 - 8) * ((ratio - 0.5) * 2));
        return `rgb(${r}, ${g}, ${b})`;
      }
    }

    // Color gradient for rating (higher = green, lower = red)
    // Average RAT is 5.98, so that's our midpoint (yellow)
    // Range: 0-12 (with 6 being neutral yellow, above = green, below = red)
    function getRatingColor(rating) {
      if (!rating || rating <= 0) return '#6b7280'; // gray for N/A
      const midRating = 6; // Average is ~5.98
      const maxRating = 12; // Elite players
      
      if (rating <= midRating) {
        // Red to Yellow (0 to 6)
        const ratio = rating / midRating;
        const r = Math.round(239 - (239 - 234) * ratio);
        const g = Math.round(68 + (179 - 68) * ratio);
        const b = Math.round(68 - (68 - 8) * ratio);
        return `rgb(${r}, ${g}, ${b})`;
      } else {
        // Yellow to Green (6 to 12)
        const ratio = Math.min((rating - midRating) / (maxRating - midRating), 1);
        const r = Math.round(234 - (234 - 34) * ratio);
        const g = Math.round(179 + (197 - 179) * ratio);
        const b = Math.round(8 + (94 - 8) * ratio);
        return `rgb(${r}, ${g}, ${b})`;
      }
    }

    // Color gradient for games played (more games = green, fewer = red)
    // Games range: 0-100 (last 365 days including playoffs), with ~50 being neutral yellow
    function getGamesColor(games) {
      if (!games || games <= 0) return '#6b7280'; // gray for N/A
      const minGames = 0;
      const maxGames = 100;
      const clampedGames = Math.max(minGames, Math.min(maxGames, games));
      const ratio = clampedGames / maxGames;
      
      // Red (few games) -> Yellow (mid) -> Green (many games)
      if (ratio <= 0.5) {
        // Red to Yellow
        const r = Math.round(239 - (239 - 234) * (ratio * 2));
        const g = Math.round(68 + (179 - 68) * (ratio * 2));
        const b = Math.round(68 - (68 - 8) * (ratio * 2));
        return `rgb(${r}, ${g}, ${b})`;
      } else {
        // Yellow to Green
        const r = Math.round(234 - (234 - 34) * ((ratio - 0.5) * 2));
        const g = Math.round(179 + (197 - 179) * ((ratio - 0.5) * 2));
        const b = Math.round(8 + (94 - 8) * ((ratio - 0.5) * 2));
        return `rgb(${r}, ${g}, ${b})`;
      }
    }

    // Get unique teams from players
    function getUniqueTeams() {
      const teamSet = new Set(players.map(p => p.team));
      return Array.from(teamSet).sort();
    }

    // Get team info (status, cap space, hardcap) from first player of that team
    function getTeamInfo(teamName) {
      const teamPlayer = players.find(p => p.team === teamName);
      if (!teamPlayer) return null;
      return {
        name: teamName,
        status: teamPlayer.teamStatus,
        capSpace: teamPlayer.capSpace,
        taxRoom: teamPlayer.taxRoom,
        apronRoom1st: teamPlayer.apronRoom1st,
        apronRoom2nd: teamPlayer.apronRoom2nd,
        isHardcap1st: teamPlayer.isHardcap1st,
        isHardcap2nd: teamPlayer.isHardcap2nd,
        logo: teamPlayer.teamLogo
      };
    }

    // Get team logo URL
    function getTeamLogo(teamName) {
      const teamPlayer = players.find(p => p.team === teamName);
      return teamPlayer?.teamLogo || '';
    }

    // Calculate trade salary (two-way players count as $0)
    function getTradeSalary(player) {
      if (player.contractStatus?.toUpperCase() === 'TWO-WAY') return 0;
      return player.salary;
    }

    // Get trade exceptions for a team
    function getTeamTPEs(teamName) {
      return tradeExceptions.filter(tpe => tpe.team === teamName);
    }

    function getTeamDraftPicks(teamName) {
      return draftPicks.filter(pick => pick.team === teamName);
    }

    function getTeamDraftRights(teamName) {
      return draftRights.filter(r => r.team === teamName);
    }

    // League minimum salary for 2025-26 season (0 years experience / rookie scale)
    const LEAGUE_MINIMUM = 1272870;

    // Get trade salary (Two-Way contracts count as $0)
    // For outgoing: use regular salary
    // For incoming SALARY MATCHING: use poison pill value if present, $0 for MSE, league minimum if minimum contract, otherwise regular salary
    // For incoming CAP IMPACT (Net): use actual salary (MSE players still count against cap)
    function getOutgoingSalary(player) {
      if (player.contractStatus && player.contractStatus.toUpperCase().includes('TWO-WAY')) {
        return 0;
      }
      return player.salary;
    }

    // For salary matching purposes
    function getIncomingSalary(player) {
      if (player.contractStatus && player.contractStatus.toUpperCase().includes('TWO-WAY')) {
        return 0;
      }
      // Players signed with Minimum Salary Exception can be traded without matching salary
      if (player.isMinSalaryException) {
        return 0;
      }
      // Poison pill takes priority
      if (player.poisonPill > 0) {
        return player.poisonPill;
      }
      // Minimum salary players count as league minimum for receiving team
      if (player.isMinimum) {
        return LEAGUE_MINIMUM;
      }
      return player.salary;
    }

    // For cap impact / Net calculations (actual salary on books)
    // For minimum players, use cap hold value if available (for cap/tax/apron calculations)
    function getCapImpactSalary(player) {
      if (player.contractStatus && player.contractStatus.toUpperCase().includes('TWO-WAY')) {
        return 0;
      }
      // Minimum players use cap hold for cap calculations
      if (player.isMinimum && player.capHold > 0) {
        return player.capHold;
      }
      // MSE players' actual salary still goes on the books
      return player.salary;
    }

    // Legacy function for backwards compatibility
    function getTradeSalary(player) {
      return getOutgoingSalary(player);
    }

    // Get players for a specific team
    function getTeamPlayers(teamName) {
      return players.filter(p => p.team === teamName);
    }

    // Calculate max incoming salary based on team status and outgoing salary
    function getMaxIncoming(status, outgoingSalary, capSpace = 0) {
      if (status === 'Cap Space') {
        return capSpace + outgoingSalary;
      } else if (status === '2nd Apron' || status === '1st Apron') {
        // Apron teams cannot take back more than 100% of outgoing
        return outgoingSalary;
      } else {
        // Below Tax or Tax Team
        return outgoingSalary * 1.75 + 250000;
      }
    }

    // Validate a team's side of the trade
    function validateTeamTrade(tradeTeam) {
      const teamInfo = getTeamInfo(tradeTeam.teamName);
      if (!teamInfo) return { valid: false, message: 'Team not found' };

      // Outgoing salary uses regular salary
      const outgoingSalary = tradeTeam.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
      // Incoming salary uses poison pill value if present (for salary matching)
      const incomingSalary = tradeTeam.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
      // Actual incoming salary for cap/apron calculations (MSE players count full salary)
      const incomingCapImpact = tradeTeam.playersIn.reduce((sum, p) => sum + getCapImpactSalary(p), 0);
      
      // Unlikely bonuses affect apron calculations
      // Outgoing players' unlikely bonuses are removed from the team's cap
      // Incoming players' unlikely bonuses are added to the team's cap
      const outgoingUnlikelyBonus = tradeTeam.playersOut.reduce((sum, p) => sum + (p.unlikelyBonus || 0), 0);
      const incomingUnlikelyBonus = tradeTeam.playersIn.reduce((sum, p) => sum + (p.unlikelyBonus || 0), 0);
      const netUnlikelyBonus = incomingUnlikelyBonus - outgoingUnlikelyBonus;
      
      // Net incoming for hardcap/apron purposes (uses ACTUAL salary + unlikely bonus adjustment)
      const netIncomingForHardcap = incomingCapImpact - outgoingSalary + netUnlikelyBonus;

      // Check hardcap FIRST - TPE doesn't help here, salary still counts against cap
      if (teamInfo.isHardcap1st && netIncomingForHardcap > teamInfo.apronRoom1st) {
        return { 
          valid: false, 
          message: `Exceeds 1st apron hardcap by ${formatSalary(netIncomingForHardcap - teamInfo.apronRoom1st)}` 
        };
      }
      if (teamInfo.isHardcap2nd && netIncomingForHardcap > teamInfo.apronRoom2nd) {
        return { 
          valid: false, 
          message: `Exceeds 2nd apron hardcap by ${formatSalary(netIncomingForHardcap - teamInfo.apronRoom2nd)}` 
        };
      }

      // Check if team would cross into a restricted tier after the trade
      const status = teamInfo.status.toUpperCase();
      
      // Teams below tax cannot take on salary that pushes them into tax if they can't handle the matching rules
      // More importantly: if a team is BELOW TAX or TAX TEAM, they use 175% + $250K rule
      // But if the net incoming pushes them PAST the 1st apron, they'd be in 1ST APRON tier which has stricter rules
      // The trade rules are based on where the team ENDS UP, not where they start
      
      // Determine what tier the team would end up in after the trade
      // IMPORTANT: Teams must satisfy the rules for EACH tier they cross through
      // Check from least restrictive to most restrictive, and fail at the first violation
      
      if (status === 'BELOW TAX') {
        // First check: crossing into Tax Team territory
        if (teamInfo.taxRoom > 0 && netIncomingForHardcap > teamInfo.taxRoom) {
          // Must satisfy Tax Team rules (125% + $100K) to cross the tax line
          const maxIncomingTax = outgoingSalary * 1.25 + 100000;
          if (incomingSalary > maxIncomingTax) {
            return {
              valid: false,
              message: `Trade would push team into tax - can only receive ${formatSalary(maxIncomingTax)}`
            };
          }
        }
        
        // Second check: crossing into 1st Apron territory
        if (teamInfo.apronRoom1st > 0 && netIncomingForHardcap > teamInfo.apronRoom1st) {
          // Must satisfy 1st Apron rules (100% - cannot take back more than outgoing)
          const maxIncoming1st = outgoingSalary;
          if (incomingSalary > maxIncoming1st) {
            return {
              valid: false,
              message: `Trade would push team into 1st apron - can only receive ${formatSalary(maxIncoming1st)}`
            };
          }
          // Also check actual cap impact (catches MSE players)
          if (incomingCapImpact > outgoingSalary) {
            return {
              valid: false,
              message: `Trade would push team into 1st apron - actual salary received exceeds outgoing by ${formatSalary(incomingCapImpact - outgoingSalary)}`
            };
          }
        }
        
        // Third check: crossing into 2nd Apron territory
        if (teamInfo.apronRoom2nd > 0 && netIncomingForHardcap > teamInfo.apronRoom2nd) {
          // Must satisfy 2nd Apron rules (100% - cannot take back more than outgoing)
          const maxIncoming2nd = outgoingSalary;
          if (incomingSalary > maxIncoming2nd) {
            return {
              valid: false,
              message: `Trade would push team into 2nd apron - can only receive ${formatSalary(maxIncoming2nd)}`
            };
          }
          // Also check actual cap impact (catches MSE players)
          if (incomingCapImpact > outgoingSalary) {
            return {
              valid: false,
              message: `Trade would push team into 2nd apron - actual salary received exceeds outgoing by ${formatSalary(incomingCapImpact - outgoingSalary)}`
            };
          }
        }
      } else if (status === 'TAX TEAM') {
        // First check: crossing into 1st Apron territory
        if (teamInfo.apronRoom1st > 0 && netIncomingForHardcap > teamInfo.apronRoom1st) {
          const maxIncoming1st = outgoingSalary;
          if (incomingSalary > maxIncoming1st) {
            return {
              valid: false,
              message: `Trade would push team into 1st apron - can only receive ${formatSalary(maxIncoming1st)}`
            };
          }
          // Also check actual cap impact (catches MSE players)
          if (incomingCapImpact > outgoingSalary) {
            return {
              valid: false,
              message: `Trade would push team into 1st apron - actual salary received exceeds outgoing by ${formatSalary(incomingCapImpact - outgoingSalary)}`
            };
          }
        }
        
        // Second check: crossing into 2nd Apron territory
        if (teamInfo.apronRoom2nd > 0 && netIncomingForHardcap > teamInfo.apronRoom2nd) {
          const maxIncoming2nd = outgoingSalary;
          if (incomingSalary > maxIncoming2nd) {
            return {
              valid: false,
              message: `Trade would push team into 2nd apron - can only receive ${formatSalary(maxIncoming2nd)}`
            };
          }
          // Also check actual cap impact (catches MSE players)
          if (incomingCapImpact > outgoingSalary) {
            return {
              valid: false,
              message: `Trade would push team into 2nd apron - actual salary received exceeds outgoing by ${formatSalary(incomingCapImpact - outgoingSalary)}`
            };
          }
        }
      } else if (status === '1ST APRON') {
        // Check: crossing into 2nd Apron territory
        if (teamInfo.apronRoom2nd > 0 && netIncomingForHardcap > teamInfo.apronRoom2nd) {
          const maxIncoming2nd = outgoingSalary;
          if (incomingSalary > maxIncoming2nd) {
            return {
              valid: false,
              message: `Trade would push team into 2nd apron - can only receive ${formatSalary(maxIncoming2nd)}`
            };
          }
          // Also check actual cap impact (catches MSE players)
          if (incomingCapImpact > outgoingSalary) {
            return {
              valid: false,
              message: `Trade would push team into 2nd apron - actual salary received exceeds outgoing by ${formatSalary(incomingCapImpact - outgoingSalary)}`
            };
          }
        }
      }
      
      // Determine the EFFECTIVE status for salary matching (where team ends up)
      let effectiveStatus = status;
      
      if (status === 'BELOW TAX') {
        if (teamInfo.apronRoom2nd > 0 && netIncomingForHardcap > teamInfo.apronRoom2nd) {
          effectiveStatus = '2ND APRON';
        } else if (teamInfo.apronRoom1st > 0 && netIncomingForHardcap > teamInfo.apronRoom1st) {
          effectiveStatus = '1ST APRON';
        } else if (teamInfo.taxRoom > 0 && netIncomingForHardcap > teamInfo.taxRoom) {
          effectiveStatus = 'TAX TEAM';
        }
      } else if (status === 'TAX TEAM') {
        if (teamInfo.apronRoom2nd > 0 && netIncomingForHardcap > teamInfo.apronRoom2nd) {
          effectiveStatus = '2ND APRON';
        } else if (teamInfo.apronRoom1st > 0 && netIncomingForHardcap > teamInfo.apronRoom1st) {
          effectiveStatus = '1ST APRON';
        }
      } else if (status === '1ST APRON') {
        if (teamInfo.apronRoom2nd > 0 && netIncomingForHardcap > teamInfo.apronRoom2nd) {
          effectiveStatus = '2ND APRON';
        }
      }

      // Calculate TPE contribution for salary MATCHING purposes only
      let tpeValue = 0;
      if (tradeTeam.tpeUsed) {
        tpeValue = tradeTeam.tpeUsed.value;
      }

      // Check salary matching using EFFECTIVE status (where team ends up after trade)
      // Rules for 2024-25 CBA:
      // - Cap Space: can absorb up to cap space + outgoing
      // - Below Tax (tiered):
      //   * Outgoing ‚â§ $7,500,000: 200% + $250K
      //   * Outgoing $7,500,001 - $29,000,000: Outgoing + $7.5M
      //   * Outgoing > $29,000,000: 125% + $250K
      // - Tax Team: 125% + $100K
      // - 1st Apron: 100% (cannot take back more than outgoing)
      // - 2nd Apron: 100% (cannot take back more than outgoing)
      let maxIncoming;
      if (effectiveStatus === 'CAP SPACE') {
        // Cap Space teams can absorb up to their cap space + any outgoing salary
        maxIncoming = teamInfo.capSpace + outgoingSalary;
      } else if (effectiveStatus === '2ND APRON' || effectiveStatus === '1ST APRON') {
        // Apron teams cannot take back more than 100% of outgoing salary
        maxIncoming = outgoingSalary;
      } else if (effectiveStatus === 'TAX TEAM') {
        // Tax teams: 125% + $100K
        maxIncoming = outgoingSalary * 1.25 + 100000;
      } else {
        // Below Tax: Tiered system
        if (outgoingSalary <= 7500000) {
          // Tier 1: 200% + $250K for outgoing up to $7.5M
          maxIncoming = outgoingSalary * 2 + 250000;
        } else if (outgoingSalary <= 29000000) {
          // Tier 2: Outgoing + $7.5M for outgoing $7.5M - $29M
          maxIncoming = outgoingSalary + 7500000;
        } else {
          // Tier 3: 125% + $250K for outgoing over $29M
          maxIncoming = outgoingSalary * 1.25 + 250000;
        }
      }
      
      // Add TPE value to max incoming for salary matching
      maxIncoming += tpeValue;

      if (incomingSalary > maxIncoming) {
        const deficit = incomingSalary - maxIncoming;
        return { 
          valid: false, 
          message: `Need to send out ${formatSalary(deficit)} more in salary` 
        };
      }
      
      // Additional check for apron teams: actual cap impact cannot exceed outgoing
      // This catches MSE players whose salary-matching value is $0 but actual salary counts against cap
      if (effectiveStatus === '1ST APRON' || effectiveStatus === '2ND APRON') {
        if (incomingCapImpact > outgoingSalary) {
          const deficit = incomingCapImpact - outgoingSalary;
          return { 
            valid: false, 
            message: `Apron team cannot receive more salary than sent - over by ${formatSalary(deficit)}` 
          };
        }
      }

      // Check for trade restrictions
      const restrictions = [];
      
      // Check roster size after trade (standard contracts only, not two-way)
      const teamPlayers = getTeamPlayers(tradeTeam.teamName);
      const currentStandardCount = teamPlayers.filter(p => 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' && 
        !p.contractStatus?.toUpperCase().includes('10-DAY')
      ).length;
      
      const outgoingStandard = tradeTeam.playersOut.filter(p => 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY')
      ).length;
      
      const incomingStandard = tradeTeam.playersIn.filter(p => 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY')
      ).length;
      
      const postTradeCount = currentStandardCount - outgoingStandard + incomingStandard;
      
      if (postTradeCount < 13) {
        const needed = 13 - postTradeCount;
        const playerWord = needed === 1 ? 'one player' : needed === 2 ? 'two players' : needed === 3 ? 'three players' : `${needed} players`;
        restrictions.push(`${tradeTeam.teamName} roster drops to ${postTradeCount} - must add ${playerWord}`);
      } else if (postTradeCount > 15) {
        const excess = postTradeCount - 15;
        const playerWord = excess === 1 ? 'one player' : excess === 2 ? 'two players' : excess === 3 ? 'three players' : `${excess} players`;
        restrictions.push(`${tradeTeam.teamName} roster goes to ${postTradeCount} - must release ${playerWord}`);
      }
      
      // Check for not aggregated players being combined with others
      const naPlayers = tradeTeam.playersOut.filter(p => p.notAggregated);
      if (naPlayers.length > 0 && tradeTeam.playersOut.length > 1) {
        naPlayers.forEach(p => {
          restrictions.push(`${p.player} cannot be aggregated with other players`);
        });
      }
      
      tradeTeam.playersOut.forEach(p => {
        if (p.tradeAvailable && p.tradeAvailable.toLowerCase() === 'not available') {
          restrictions.push(`${p.player} cannot be traded before deadline`);
        } else if (p.tradeAvailable) {
          restrictions.push(`${p.player} available ${p.tradeAvailable}`);
        }
        if (p.noTradeClause) {
          restrictions.push(`${p.player} has a no-trade clause`);
        }
      });

      // If there are NA violations, trade is invalid
      if (naPlayers.length > 0 && tradeTeam.playersOut.length > 1) {
        return {
          valid: false,
          message: `${naPlayers.map(p => p.player).join(', ')} cannot be aggregated with other players`,
          warnings: restrictions
        };
      }

      return { 
        valid: true, 
        message: restrictions.length > 0 ? restrictions.join('; ') : 'Trade works',
        warnings: restrictions
      };
    }

    // Check 2nd Apron specific restrictions for a team trade
    // Returns { valid: boolean, message?: string }
    function check2ndApronRestrictions(tradeTeam) {
      if (!tradeTeam.teamName) return { valid: true };
      const teamInfo = getTeamInfo(tradeTeam.teamName);
      if (!teamInfo) return { valid: true };
      
      const status = teamInfo.status?.toUpperCase() || '';
      const is2ndApron = status.includes('2ND APRON');
      
      if (is2ndApron) {
        // 2nd Apron teams cannot send cash
        if (tradeTeam.cashOut && tradeTeam.cashOut.length > 0) {
          return { valid: false, message: `${tradeTeam.teamName} (2nd Apron) cannot send cash in a trade` };
        }
        
        // 2nd Apron teams cannot aggregate salaries (more than 1 player out)
        if (tradeTeam.playersOut.length > 1) {
          return { valid: false, message: `${tradeTeam.teamName} (2nd Apron) cannot aggregate player salaries` };
        }
      }
      
      return { valid: true };
    }

    // Validate entire trade
    // Stepien Rule validation
    // Teams must have at least one first-round pick in consecutive years
    function validateStepienRule(teamName, teamIndex) {
      const team = tradeTeams[teamIndex];
      const picksOut = team.picksOut || [];
      
      // Only check first-round picks being traded out
      const firstRoundPicksOut = picksOut.filter(p => p.round === '1st');
      
      // Get incoming first-round picks from other teams
      const incomingFirstRoundPicks = [];
      tradeTeams.forEach((otherTeam, otherIndex) => {
        if (otherIndex !== teamIndex && otherTeam.picksOut) {
          otherTeam.picksOut.forEach(pick => {
            if (pick.round === '1st') {
              // Check if this pick is coming to our team
              const dest = pick.destination !== undefined ? pick.destination : (tradeTeams.length === 2 ? teamIndex : undefined);
              if (dest === teamIndex) {
                incomingFirstRoundPicks.push(pick);
              }
            }
          });
        }
      });
      
      // If not trading any first-round picks, no Stepien concern
      if (firstRoundPicksOut.length === 0) return { valid: true };
      
      // Get all first-round picks for this team from the master list
      const teamFirstRoundPicks = draftPicks.filter(p => p.team === teamName && p.round === '1st');
      
      // Years to check (need consecutive year coverage)
      const years = [2026, 2027, 2028, 2029, 2030, 2031, 2032];
      
      // Helper to check if a specific pick is being traded out
      const isPickBeingTraded = (pick) => {
        return firstRoundPicksOut.some(p => 
          p.year === pick.year && p.round === pick.round && p.notes === pick.notes
        );
      };
      
      // For each year, determine if team will have a "guaranteed" pick after trade
      const guaranteedPicksByYear = {};
      
      years.forEach(year => {
        const yearStr = year.toString();
        const picksThisYear = teamFirstRoundPicks.filter(p => p.year === yearStr);
        
        let hasGuaranteedPick = false;
        
        // Check owned picks that are NOT being traded AND are sure picks
        picksThisYear.forEach(pick => {
          const beingTraded = isPickBeingTraded(pick);
          
          if (!beingTraded && pick.surePick === 'YES') {
            hasGuaranteedPick = true;
          }
        });
        
        // Check incoming picks for this year (only count sure picks)
        const incomingThisYear = incomingFirstRoundPicks.filter(p => p.year === yearStr);
        incomingThisYear.forEach(pick => {
          if (pick.surePick === 'YES') {
            hasGuaranteedPick = true;
          }
        });
        
        guaranteedPicksByYear[yearStr] = hasGuaranteedPick;
      });
      
      // Check for linked pick coverage
      // If two years have conditional picks linked to each other and NEITHER is being traded,
      // then one of them WILL convey, covering that consecutive pair
      const linkedCoverage = {};
      
      years.forEach(year => {
        const yearStr = year.toString();
        const picksThisYear = teamFirstRoundPicks.filter(p => p.year === yearStr);
        
        picksThisYear.forEach(pick => {
          if (pick.linkedTo && !isPickBeingTraded(pick)) {
            const linkedYear = pick.linkedTo;
            const linkedPicks = teamFirstRoundPicks.filter(p => p.year === linkedYear);
            
            // Check if the linked pick exists and is also not being traded
            const linkedPickNotBeingTraded = linkedPicks.some(lp => lp.linkedTo && !isPickBeingTraded(lp));
            
            if (linkedPickNotBeingTraded) {
              // This consecutive pair is covered by linked picks
              const pairKey = [yearStr, linkedYear].sort().join('-');
              linkedCoverage[pairKey] = true;
            }
          }
        });
      });
      
      // Check for consecutive years without a guaranteed pick
      for (let i = 0; i < years.length - 1; i++) {
        const year1 = years[i].toString();
        const year2 = years[i + 1].toString();
        
        // Check if this pair is covered by either:
        // 1. At least one year has a guaranteed (sure) pick
        // 2. The pair is covered by linked conditional picks (neither being traded)
        const pairKey = [year1, year2].sort().join('-');
        const coveredByLinked = linkedCoverage[pairKey];
        
        if (!guaranteedPicksByYear[year1] && !guaranteedPicksByYear[year2] && !coveredByLinked) {
          return { 
            valid: false, 
            message: `Stepien Rule: ${teamName} must have a 1st round pick in ${year1} or ${year2}`
          };
        }
      }
      
      return { valid: true };
    }

    function validateTrade() {
      // Teams involved in the trade (sending players, receiving players, or trading any assets)
      const teamsWithAssets = tradeTeams.filter(t => t.teamName && (
        t.playersOut.length > 0 || 
        t.playersIn.length > 0 || 
        (t.picksOut && t.picksOut.length > 0) ||
        (t.rightsOut && t.rightsOut.length > 0) ||
        (t.cashOut && t.cashOut.length > 0)
      ));
      const teamsSendingPlayers = tradeTeams.filter(t => t.teamName && t.playersOut.length > 0);
      const teamsSendingAssets = tradeTeams.filter(t => t.teamName && (
        (t.picksOut && t.picksOut.length > 0) ||
        (t.rightsOut && t.rightsOut.length > 0) ||
        (t.cashOut && t.cashOut.length > 0)
      ));
      
      // Need at least some assets being traded
      if (teamsSendingPlayers.length < 1 && teamsSendingAssets.length < 1) {
        return { valid: false, message: 'Add players or assets to trade', type: 'warning' };
      }

      // For asset-only trades (no players), need at least 2 teams trading assets
      if (teamsSendingPlayers.length < 1 && teamsSendingAssets.length < 2) {
        return { valid: false, message: 'Select second team to trade assets', type: 'warning' };
      }

      // For trades with players, need at least 2 teams involved
      if (teamsSendingPlayers.length >= 1 && teamsWithAssets.length < 2) {
        return { valid: false, message: 'Select destination for players', type: 'warning' };
      }

      // Check that all players have destinations assigned
      let missingDestinations = false;
      teamsSendingPlayers.forEach(t => {
        t.playersOut.forEach(p => {
          if (p.destination === undefined) {
            missingDestinations = true;
          }
        });
      });

      if (missingDestinations) {
        return { valid: false, message: 'Select destination team for all players', type: 'warning' };
      }

      // Check that every team involved in the trade sends something
      // A team is "involved" if they receive players, picks, rights, or cash
      const teamsReceiving = tradeTeams.filter(t => {
        if (!t.teamName) return false;
        // Check if receiving players
        if (t.playersIn.length > 0) return true;
        // Check if receiving picks from other teams
        const receivingPicks = tradeTeams.some((other, otherIdx) => 
          other.picksOut?.some(p => p.destination === tradeTeams.indexOf(t))
        );
        if (receivingPicks) return true;
        // Check if receiving rights from other teams
        const receivingRights = tradeTeams.some((other, otherIdx) => 
          other.rightsOut?.some(r => r.destination === tradeTeams.indexOf(t))
        );
        if (receivingRights) return true;
        // Check if receiving cash from other teams
        const receivingCash = tradeTeams.some((other, otherIdx) => 
          other.cashOut?.some(c => c.destination === tradeTeams.indexOf(t))
        );
        if (receivingCash) return true;
        return false;
      });

      // Check each receiving team sends something back
      for (const t of teamsReceiving) {
        const isSending = t.playersOut.length > 0 || 
                         (t.picksOut && t.picksOut.length > 0) || 
                         (t.rightsOut && t.rightsOut.length > 0) || 
                         (t.cashOut && t.cashOut.length > 0);
        if (!isSending) {
          return { valid: false, message: `${t.teamName} must send something in return (players, picks, rights, or cash)`, type: 'invalid' };
        }
      }

      // Validate each team's side (only for teams with players)
      let allValid = true;
      let allWarnings = [];
      let invalidMessages = [];
      
      const teamsWithPlayers = tradeTeams.filter(t => t.teamName && (t.playersOut.length > 0 || t.playersIn.length > 0));
      teamsWithPlayers.forEach(t => {
        const result = validateTeamTrade(t);
        if (!result.valid) {
          allValid = false;
          invalidMessages.push(`${t.teamName}: ${result.message}`);
        }
        if (result.warnings) {
          allWarnings = allWarnings.concat(result.warnings);
        }
      });

      if (!allValid) {
        return { valid: false, message: invalidMessages.join(' | '), type: 'invalid' };
      }

      // 2nd Apron specific restrictions
      tradeTeams.forEach(t => {
        if (!t.teamName) return;
        const teamInfo = getTeamInfo(t.teamName);
        if (!teamInfo) return;
        
        const status = teamInfo.status?.toUpperCase() || '';
        const is2ndApron = status.includes('2ND APRON');
        
        if (is2ndApron) {
          // 2nd Apron teams cannot send cash
          if (t.cashOut && t.cashOut.length > 0) {
            allValid = false;
            invalidMessages.push(`${t.teamName} (2nd Apron) cannot send cash in a trade`);
          }
          
          // 2nd Apron teams cannot aggregate salaries (more than 1 player out)
          if (t.playersOut.length > 1) {
            allValid = false;
            invalidMessages.push(`${t.teamName} (2nd Apron) cannot aggregate player salaries`);
          }
        }
      });

      if (!allValid) {
        return { valid: false, message: invalidMessages.join(' | '), type: 'invalid' };
      }

      // Check "No Trade To" restrictions (players who can't be traded to specific teams)
      // This applies when a player was waived/traded from a team in the current season
      tradeTeams.forEach((team, teamIndex) => {
        team.playersOut.forEach(player => {
          if (player.noTradeTo && player.destination !== undefined) {
            const destTeam = tradeTeams[player.destination];
            if (destTeam && destTeam.teamName) {
              const restrictedTeams = player.noTradeTo.split(',').map(t => t.trim().toLowerCase());
              const destTeamLower = destTeam.teamName.toLowerCase();
              if (restrictedTeams.some(rt => destTeamLower.includes(rt) || rt.includes(destTeamLower))) {
                allValid = false;
                invalidMessages.push(`${player.player} cannot be traded to ${destTeam.teamName} (waived/traded from there this season)`);
              }
            }
          }
        });
      });

      if (!allValid) {
        return { valid: false, message: invalidMessages.join(' | '), type: 'invalid' };
      }

      // Validate Stepien Rule for each team trading picks
      tradeTeams.forEach((t, teamIndex) => {
        if (t.teamName && t.picksOut && t.picksOut.length > 0) {
          const stepienResult = validateStepienRule(t.teamName, teamIndex);
          if (!stepienResult.valid) {
            allValid = false;
            invalidMessages.push(stepienResult.message);
          }
        }
      });

      if (!allValid) {
        return { valid: false, message: invalidMessages.join(' | '), type: 'invalid' };
      }

      // Check that teams using TPE to receive players must send something back
      tradeTeams.forEach(t => {
        if (t.teamName && t.tpeUsed && t.playersIn.length > 0 && t.playersOut.length === 0) {
          // Team is receiving players via TPE but sending no players
          // They must send at least one asset (pick, rights, or cash)
          const hasAssets = (t.picksOut && t.picksOut.length > 0) ||
                           (t.rightsOut && t.rightsOut.length > 0) ||
                           (t.cashOut && t.cashOut.length > 0);
          if (!hasAssets) {
            allValid = false;
            invalidMessages.push(`${t.teamName} must send an asset (pick, rights, or cash) when using TPE`);
          }
        }
        
        // 1st and 2nd Apron teams cannot use TPEs (after regular season ends)
        if (t.teamName && t.tpeUsed) {
          const teamInfo = getTeamInfo(t.teamName);
          if (teamInfo) {
            const status = teamInfo.status?.toUpperCase() || '';
            if (status.includes('1ST APRON') || status.includes('2ND APRON')) {
              allValid = false;
              invalidMessages.push(`${t.teamName} (${status.includes('2ND') ? '2nd' : '1st'} Apron) cannot use Trade Exceptions`);
            }
          }
        }
      });
      
      // Check if 1st/2nd Apron teams would create a TPE (outgoing > incoming)
      // These teams cannot create new TPEs from trades
      tradeTeams.forEach(t => {
        if (!t.teamName) return;
        const teamInfo = getTeamInfo(t.teamName);
        if (!teamInfo) return;
        
        const status = teamInfo.status?.toUpperCase() || '';
        if (status.includes('1ST APRON') || status.includes('2ND APRON')) {
          const outgoing = t.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
          const incoming = t.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
          
          // If sending more salary than receiving, they would create a TPE (which they can't)
          if (outgoing > incoming && t.playersOut.length > 0 && t.playersIn.length > 0) {
            const tpeAmount = outgoing - incoming;
            if (tpeAmount > 250000) { // Only flag if significant TPE would be created
              allWarnings.push(`${t.teamName} (${status.includes('2ND') ? '2nd' : '1st'} Apron) cannot create a TPE from this trade (would generate ${formatSalary(tpeAmount)} TPE)`);
            }
          }
        }
      });

      if (!allValid) {
        return { valid: false, message: invalidMessages.join(' | '), type: 'invalid' };
      }

      // Check if warnings are only date-related or NTC (trade is valid but pending approval/date)
      if (allWarnings.length > 0) {
        const hasDateWarnings = allWarnings.some(w => w.includes('available') && !w.includes('no-trade'));
        const hasNTCWarnings = allWarnings.some(w => w.includes('no-trade clause'));
        const hasBlockingWarnings = allWarnings.some(w => w.includes('cannot be traded before deadline'));
        const hasTPECreationWarnings = allWarnings.some(w => w.includes('cannot create a TPE'));
        const hasRosterWarnings = allWarnings.some(w => w.includes('roster drops to') || w.includes('roster goes to'));
        
        // Filter out TPE creation warnings - they're informational only and don't affect trade validity
        const nonTPEWarnings = allWarnings.filter(w => !w.includes('cannot create a TPE'));
        
        if (hasBlockingWarnings) {
          return { valid: true, message: nonTPEWarnings.join('; '), type: 'warning' };
        }
        
        // Roster warnings alone don't make trade orange - treat like NTC (valid with note)
        const onlyRosterAndNTCWarnings = nonTPEWarnings.every(w => 
          w.includes('no-trade clause') || 
          w.includes('roster drops to') || 
          w.includes('roster goes to') ||
          w.includes('must add') ||
          w.includes('must release')
        );
        
        if (hasDateWarnings && !hasNTCWarnings) {
          // Extract the date from the warning message
          const dateMatch = nonTPEWarnings.find(w => w.includes('available'))?.match(/available\s+(.+)/);
          const date = dateMatch ? dateMatch[1] : 'a future date';
          return { valid: true, message: nonTPEWarnings.join('; '), type: 'pending-date', pendingDate: date };
        }
        
        if (hasNTCWarnings && !hasDateWarnings) {
          return { valid: true, message: nonTPEWarnings.join('; '), type: 'pending-ntc' };
        }
        
        if (hasNTCWarnings && hasDateWarnings) {
          const dateMatch = nonTPEWarnings.find(w => w.includes('available'))?.match(/available\s+(.+)/);
          const date = dateMatch ? dateMatch[1] : 'a future date';
          return { valid: true, message: nonTPEWarnings.join('; '), type: 'pending-both', pendingDate: date };
        }
        
        // If only TPE creation warnings remain, trade is fully valid (green)
        if (nonTPEWarnings.length === 0) {
          return { valid: true, message: 'All teams can complete this trade', type: 'valid' };
        }
        
        // If only roster warnings (and maybe NTC), trade is valid (green) with notes
        if (onlyRosterAndNTCWarnings) {
          return { valid: true, message: nonTPEWarnings.join('; '), type: hasNTCWarnings ? 'pending-ntc' : 'valid' };
        }
        
        return { valid: true, message: nonTPEWarnings.join('; '), type: 'warning' };
      }

      return { valid: true, message: 'All teams can complete this trade', type: 'valid' };
    }

    // Distribute players based on their assigned destinations
    function redistributePlayers(addAutoCash = false) {
      // Clear all incoming players
      tradeTeams.forEach(t => t.playersIn = []);

      // For each player being sent out, add them to their destination team's incoming
      tradeTeams.forEach((team, teamIndex) => {
        team.playersOut.forEach(player => {
          if (player.destination !== undefined && player.destination !== teamIndex) {
            const destTeam = tradeTeams[player.destination];
            if (destTeam) {
              destTeam.playersIn.push(player);
            }
          }
        });
      });
      
      // Auto-add cash considerations for teams that send assets but receive nothing
      // Only for generated trades, not manual trades
      if (!addAutoCash) return;
      
      tradeTeams.forEach((team, teamIndex) => {
        if (!team.teamName) return;
        
        // Check if team is sending anything
        const isSending = team.playersOut.length > 0 || 
                         (team.picksOut && team.picksOut.length > 0) || 
                         (team.rightsOut && team.rightsOut.length > 0);
        
        if (!isSending) return;
        
        // Check if team is receiving anything
        const isReceivingPlayers = team.playersIn.length > 0;
        const isReceivingPicks = tradeTeams.some((otherTeam, otherIdx) => 
          otherIdx !== teamIndex && 
          otherTeam.picksOut?.some(p => p.destination === teamIndex)
        );
        const isReceivingRights = tradeTeams.some((otherTeam, otherIdx) => 
          otherIdx !== teamIndex && 
          otherTeam.rightsOut?.some(r => r.destination === teamIndex)
        );
        const isReceivingCash = tradeTeams.some((otherTeam, otherIdx) => 
          otherIdx !== teamIndex && 
          otherTeam.cashOut?.some(c => c.destination === teamIndex)
        );
        
        const isReceiving = isReceivingPlayers || isReceivingPicks || isReceivingRights || isReceivingCash;
        
        // If sending but not receiving, find a team to send cash from
        if (!isReceiving) {
          // Strategy 1: Find the team that directly receives assets from this team
          let bestCashSender = -1;
          let maxValueReceived = 0;
          
          team.playersOut.forEach(p => {
            if (p.destination !== undefined && p.destination !== teamIndex) {
              const value = p.salary || 0;
              if (value > maxValueReceived) {
                maxValueReceived = value;
                bestCashSender = p.destination;
              }
            }
          });
          
          // Also check picks and rights
          if (bestCashSender === -1) {
            team.picksOut?.forEach(p => {
              if (p.destination !== undefined && p.destination !== teamIndex) {
                bestCashSender = p.destination;
              }
            });
          }
          if (bestCashSender === -1) {
            team.rightsOut?.forEach(r => {
              if (r.destination !== undefined && r.destination !== teamIndex) {
                bestCashSender = r.destination;
              }
            });
          }
          
          // Strategy 2: If still no sender, pick any other team with players
          if (bestCashSender === -1) {
            for (let i = 0; i < tradeTeams.length; i++) {
              if (i !== teamIndex && tradeTeams[i].teamName && tradeTeams[i].playersIn.length > 0) {
                bestCashSender = i;
                break;
              }
            }
          }
          
          // Strategy 3: Just pick the first other active team
          if (bestCashSender === -1) {
            bestCashSender = tradeTeams.findIndex((t, idx) => idx !== teamIndex && t.teamName);
          }
          
          // Add cash from the best sender
          if (bestCashSender >= 0) {
            const cashSenderTeam = tradeTeams[bestCashSender];
            if (!cashSenderTeam.cashOut) cashSenderTeam.cashOut = [];
            // Check if cash already being sent to this team
            const alreadySendingCash = cashSenderTeam.cashOut.some(c => c.destination === teamIndex);
            if (!alreadySendingCash) {
              cashSenderTeam.cashOut.push({ destination: teamIndex });
            }
          }
        }
      });
    }

    // Get other active teams (for destination dropdown)
    function getOtherActiveTeams(currentTeamIndex) {
      return tradeTeams
        .map((t, i) => ({ index: i, name: t.teamName }))
        .filter(t => t.name && t.index !== currentTeamIndex);
    }

    // Render a single team card
    function renderTeamCard(tradeTeam, index) {
      const teamInfo = tradeTeam.teamName ? getTeamInfo(tradeTeam.teamName) : null;
      const validation = tradeTeam.teamName && (tradeTeam.playersOut.length > 0 || tradeTeam.playersIn.length > 0) 
        ? validateTeamTrade(tradeTeam) 
        : null;
      
      // Check if overall trade is valid (for mobile roster collapse)
      const globalValidation = validateTrade();
      const isTradeValid = globalValidation.valid || globalValidation.type?.startsWith('pending');

      const outgoingSalary = tradeTeam.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
      const incomingSalary = tradeTeam.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
      // For Net (cap impact), use actual salaries - MSE players still go on books
      const incomingCapImpact = tradeTeam.playersIn.reduce((sum, p) => sum + getCapImpactSalary(p), 0);
      const netSalary = incomingCapImpact - outgoingSalary;

      const cardClass = validation ? (validation.valid ? 'valid' : 'invalid') : '';

      const availableTeams = getUniqueTeams().filter(t => 
        t === tradeTeam.teamName || !tradeTeams.some(tt => tt.teamName === t)
      );

      const otherTeams = getOtherActiveTeams(index);
      
      const hasPlayers = tradeTeam.playersOut.length > 0 || tradeTeam.playersIn.length > 0;
      const hasTeam = !!tradeTeam.teamName;

      return `
        <div class="team-card ${cardClass}" data-index="${index}">
          <!-- Team dropdown always on top -->
          <div class="team-header">
            ${!hasPlayers && teamInfo && teamInfo.logo ? `<img src="${teamInfo.logo}" class="team-logo" alt="" onerror="this.style.display='none'">` : ''}
            <select class="team-select" data-index="${index}">
              <option value="">Select Team...</option>
              ${availableTeams.map(t => `
                <option value="${t}" ${t === tradeTeam.teamName ? 'selected' : ''}>${t}</option>
              `).join('')}
            </select>
            ${tradeTeams.length > 2 ? `
              <button class="remove-team-btn" data-index="${index}">√ó</button>
            ` : ''}
          </div>
          
          <div class="team-body">
            <div class="trade-content" data-trade-content="${index}">
              ${hasPlayers ? `
              <!-- State 3: Team with players - show TRADES header -->
              <div class="players-out">
                <div class="section-header">
                  ${teamInfo && teamInfo.logo ? `<img src="${teamInfo.logo}" class="section-header-logo" alt="" onerror="this.style.display='none'">` : ''}
                  <span class="section-header-text trades">${tradeTeam.teamName} ${isTeamPlural(tradeTeam.teamName) ? 'Trade' : 'Trades'}</span>
                </div>
              ` : `
              <!-- State 1 & 2: No players yet -->
              <div class="players-out">
              `}
                ${tradeTeam.playersOut.map((p, pIndex) => {
                  const isTwoWay = p.contractStatus?.toUpperCase() === 'TWO-WAY';
                  const outgoingValue = getOutgoingSalary(p);
                  const tradePct = getPlayerTradePercentage(p.playerId);
                  return `
                  <div class="player-chip">
                    <div class="player-chip-row">
                      ${p.headshot ? `<img src="${p.headshot}" class="player-headshot" alt="" onerror="this.style.display='none'">` : ''}
                      <div class="player-chip-info">
                        <div class="player-chip-name">
                          ${p.player}
                          <span class="player-info-wrapper">
                            <span class="player-info-icon">‚Ñπ</span>
                            <div class="player-info-tooltip">
                              <div class="player-info-name">${p.player}</div>
                              <div class="player-info-team">${p.team}${p.position ? ` ‚Ä¢ ${p.position}` : ''}</div>
                              <div class="player-info-row">
                                <span class="player-info-label">Age</span>
                                <span class="player-info-value" style="color: ${getAgeColor(p.age)}">${p.age || 'N/A'}</span>
                              </div>
                              <div class="player-info-row">
                                <span class="player-info-label">Last 365 days</span>
                                <span class="player-info-value"><span style="color: ${getRatingColor(p.globalRating)}">${p.globalRating ? p.globalRating.toFixed(1) : 'N/A'} RAT</span>${p.gamesPlayed ? ` ‚Ä¢ <span style="color: ${getGamesColor(p.gamesPlayed)}">${p.gamesPlayed} G</span>` : ''}</span>
                              </div>
                              <div class="player-info-row">
                                <span class="player-info-label">Contract ends</span>
                                <span class="player-info-value">${p.contractEnd || 'N/A'}</span>
                              </div>
                              <div class="player-info-row">
                                <span class="player-info-label">Total Guaranteed</span>
                                <span class="player-info-value">${formatSalary(p.guaranteedMoney || 0)}</span>
                              </div>
                              ${tradePct > 0 ? `<div class="player-info-row">
                                <span class="player-info-label">Trade Activity</span>
                                <span class="player-info-value" style="color: ${tradePct >= 3 ? '#ef4444' : '#6366f1'}">${tradePct}% of trades</span>
                              </div>` : ''}
                              ${p.noTradeTo ? `<div class="player-info-row">
                                <span class="player-info-label">Can't trade to</span>
                                <span class="player-info-value" style="color: #ef4444">${p.noTradeTo}</span>
                              </div>` : ''}
                            </div>
                          </span>
                          ${tradePct >= 3 ? `<span class="trending-badge" title="Trending: Appears in ${tradePct}% of trades">üî•</span>` : ''}
                          ${p.isOut ? `<span class="injury-badge" title="${p.injuryReason || 'Inactive'}">‚úö</span>` : ''}
                          ${isTwoWay ? '<span class="tw-badge" title="Two-Way Contract">TW</span>' : ''}
                          ${p.noTradeClause ? '<span class="ntc-badge" title="No-Trade Clause">NTC</span>' : ''}
                          ${p.notAggregated ? '<span class="na-badge" title="Can\'t be aggregated">NA</span>' : ''}
                          ${p.poisonPill > 0 ? '<span class="pp-badge" title="Poison Pill Provision">PP</span>' : ''}
                          ${p.tradeKicker > 0 ? `<span class="tk-badge" title="Trade Kicker: ${p.tradeKicker}%">TK</span>` : ''}
                          ${p.isMinSalaryException ? '<span class="mse-badge" title="Minimum Salary Exception - No salary matching required">MSE</span>' : ''}
                          ${p.isMinimum && !p.isMinSalaryException ? '<span class="min-badge" title="Minimum Salary">MIN</span>' : ''}
                          ${p.tradeAvailable ? '<span class="restriction-badge" title="Trade Restriction">!</span>' : ''}
                        </div>
                        <div class="player-chip-salary">${formatSalary(outgoingValue)}${isTwoWay && p.salary > 0 ? ` <span style="color: #6366f1; font-size: 0.7em;">(actual ${formatSalary(p.salary)})</span>` : ''}${p.isMinSalaryException ? ` <span style="color: #10b981; font-size: 0.7em;">‚Üí $0 incoming</span>` : ''}${p.poisonPill > 0 ? ` <span style="color: #ec4899; font-size: 0.7em;">‚Üí ${formatSalary(p.poisonPill)}</span>` : ''}${p.isMinimum && !p.poisonPill && !p.isMinSalaryException ? ` <span style="color: #22c55e; font-size: 0.7em;">‚Üí ${formatSalary(LEAGUE_MINIMUM)}</span>` : ''}</div>
                      </div>
                      <button class="player-chip-remove" data-team="${index}" data-player="${pIndex}">√ó</button>
                    </div>
                    ${otherTeams.length > 0 ? `
                      <div class="player-destination">
                        <span class="player-destination-label">‚Üí To:</span>
                        <select class="player-destination-select" data-team="${index}" data-player="${pIndex}">
                          <option value="">Select team...</option>
                          ${otherTeams.map(t => `
                            <option value="${t.index}" ${p.destination === t.index ? 'selected' : ''}>${t.name}</option>
                          `).join('')}
                        </select>
                      </div>
                    ` : ''}
                  </div>
                `}).join('')}
                ${(tradeTeam.picksOut || []).map((pick, pickIdx) => {
                  const isConditional = pick.surePick !== 'YES';
                  // For outgoing picks, show team name if notes is "Own pick" or similar, or if fromTeam is undefined/same as trading team
                  let pickSource;
                  if (pick.notes && !pick.notes.toLowerCase().includes('own pick')) {
                    pickSource = pick.notes;
                  } else if (!pick.fromTeam || pick.fromTeam === tradeTeam.teamName) {
                    pickSource = `${tradeTeam.teamName} pick`;
                  } else {
                    pickSource = `From ${pick.fromTeam}`;
                  }
                  return `
                    <div class="player-chip" style="background: var(--orange-dim); border-color: var(--orange);">
                      <div class="player-chip-row">
                        <div class="player-chip-info">
                          <div class="player-chip-name" style="color: var(--orange);">
                            üìã ${pick.year} ${pick.round} Round Pick
                            ${isConditional ? `<span class="pick-conditional" title="${pick.notes || 'Conditional pick'}">COND</span>` : ''}
                          </div>
                          <div class="player-chip-salary" style="font-size: 0.7em; color: var(--text-secondary);">${pickSource}</div>
                        </div>
                        <button class="player-chip-remove pick-remove" data-team="${index}" data-pick="${pickIdx}">√ó</button>
                      </div>
                      ${otherTeams.length > 0 ? `
                        <div class="player-destination">
                          <span class="player-destination-label">‚Üí To:</span>
                          <select class="player-destination-select pick-destination-select" data-team="${index}" data-pick="${pickIdx}">
                            <option value="">Select team...</option>
                            ${otherTeams.map(t => `
                              <option value="${t.index}" ${pick.destination === t.index ? 'selected' : ''}>${t.name}</option>
                            `).join('')}
                          </select>
                        </div>
                      ` : ''}
                    </div>
                  `;
                }).join('')}
                ${(tradeTeam.rightsOut || []).map((rights, rightsIdx) => {
                  return `
                    <div class="player-chip" style="background: rgba(168, 85, 247, 0.15); border-color: #a855f7;">
                      <div class="player-chip-row">
                        <div class="player-chip-info">
                          <div class="player-chip-name" style="color: #a855f7;">
                            üéì Rights to ${rights.playerName}
                          </div>
                          <div class="player-chip-salary" style="font-size: 0.7em; color: var(--text-secondary);">Drafted ${rights.draftedYear}</div>
                        </div>
                        <button class="player-chip-remove rights-remove" data-team="${index}" data-rights="${rightsIdx}">√ó</button>
                      </div>
                      ${otherTeams.length > 0 ? `
                        <div class="player-destination">
                          <span class="player-destination-label">‚Üí To:</span>
                          <select class="player-destination-select rights-destination-select" data-team="${index}" data-rights="${rightsIdx}">
                            <option value="">Select team...</option>
                            ${otherTeams.map(t => `
                              <option value="${t.index}" ${rights.destination === t.index ? 'selected' : ''}>${t.name}</option>
                            `).join('')}
                          </select>
                        </div>
                      ` : ''}
                    </div>
                  `;
                }).join('')}
                ${(tradeTeam.cashOut || []).map((cash, cashIdx) => {
                  return `
                    <div class="player-chip" style="background: rgba(34, 197, 94, 0.15); border-color: #22c55e;">
                      <div class="player-chip-row">
                        <div class="player-chip-info">
                          <div class="player-chip-name" style="color: #22c55e;">
                            üíµ Cash Considerations
                          </div>
                        </div>
                        <button class="player-chip-remove cash-remove" data-team="${index}" data-cash="${cashIdx}">√ó</button>
                      </div>
                      ${otherTeams.length > 0 ? `
                        <div class="player-destination">
                          <span class="player-destination-label">‚Üí To:</span>
                          <select class="player-destination-select cash-destination-select" data-team="${index}" data-cash="${cashIdx}">
                            <option value="">Select team...</option>
                            ${otherTeams.map(t => `
                              <option value="${t.index}" ${cash.destination === t.index ? 'selected' : ''}>${t.name}</option>
                            `).join('')}
                          </select>
                        </div>
                      ` : ''}
                    </div>
                  `;
                }).join('')}
                ${tradeTeam.tpeUsed ? (() => {
                  // Calculate TPE amount actually used
                  const outgoingSalary = tradeTeam.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
                  const incomingSalary = tradeTeam.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
                  const deficit = incomingSalary - outgoingSalary;
                  const tpeAmountUsed = deficit > 0 ? Math.min(tradeTeam.tpeUsed.value, deficit) : 0;
                  if (tpeAmountUsed <= 0) return '';
                  return `
                  <div class="player-chip" style="background: var(--green-dim); border-color: var(--green);">
                    <div class="player-chip-row">
                      <div class="player-chip-info">
                        <div class="player-chip-name" style="color: var(--green);">
                          üìÑ Trade Exception Used
                        </div>
                        <div class="player-chip-salary" style="color: var(--green);">${formatSalary(tpeAmountUsed)}</div>
                      </div>
                    </div>
                  </div>
                  `;
                })() : ''}
              </div>
            
            ${(() => {
              // Get incoming assets based on destination
              const incomingPicks = [];
              const incomingRights = [];
              let incomingCash = 0;
              
              tradeTeams.forEach((otherTeam, otherIndex) => {
                if (otherIndex !== index && otherTeam.teamName) {
                  // Check picks with this team as destination
                  if (otherTeam.picksOut) {
                    otherTeam.picksOut.forEach(pick => {
                      // In 2-team trade, auto-destination to other team; in multi-team, use explicit destination
                      const dest = pick.destination !== undefined ? pick.destination : (tradeTeams.length === 2 ? index : undefined);
                      if (dest === index) {
                        incomingPicks.push({...pick, fromTeam: otherTeam.teamName});
                      }
                    });
                  }
                  // Check rights with this team as destination
                  if (otherTeam.rightsOut) {
                    otherTeam.rightsOut.forEach(rights => {
                      const dest = rights.destination !== undefined ? rights.destination : (tradeTeams.length === 2 ? index : undefined);
                      if (dest === index) {
                        incomingRights.push({...rights, fromTeam: otherTeam.teamName});
                      }
                    });
                  }
                  // Check cash with this team as destination (now array)
                  if (otherTeam.cashOut && otherTeam.cashOut.length > 0) {
                    otherTeam.cashOut.forEach(cash => {
                      const dest = cash.destination !== undefined ? cash.destination : (tradeTeams.length === 2 ? index : undefined);
                      if (dest === index) {
                        incomingCash++;
                      }
                    });
                  }
                }
              });
              
              const hasIncoming = tradeTeam.playersIn.length > 0 || incomingPicks.length > 0 || incomingRights.length > 0 || incomingCash > 0;
              
              if (!hasIncoming) return '';
              
              return `
              <div class="players-in">
                <div class="section-header">
                  ${teamInfo && teamInfo.logo ? `<img src="${teamInfo.logo}" class="section-header-logo" alt="" onerror="this.style.display='none'">` : ''}
                  <span class="section-header-text acquires">${tradeTeam.teamName || 'Team'} ${isTeamPlural(tradeTeam.teamName) ? 'Acquire' : 'Acquires'}</span>
                </div>
                ${tradeTeam.playersIn.map(p => {
                  const incomingValue = getIncomingSalary(p);
                  const isTwoWay = p.contractStatus?.toUpperCase() === 'TWO-WAY';
                  const showAdjusted = p.poisonPill > 0 || p.isMinimum || p.isMinSalaryException || (isTwoWay && p.salary > 0);
                  const adjustedColor = (p.isMinimum || p.isMinSalaryException) ? '#10b981' : (isTwoWay ? '#6366f1' : '#ec4899');
                  return `
                    <div class="player-chip incoming">
                      <div class="player-chip-row">
                        ${p.headshot ? `<img src="${p.headshot}" class="player-headshot" alt="" onerror="this.style.display='none'">` : ''}
                        <div class="player-chip-info">
                          <div class="player-chip-name">
                            ${p.player}
                            <span class="player-info-wrapper">
                              <span class="player-info-icon">‚Ñπ</span>
                              <div class="player-info-tooltip">
                                <div class="player-info-name">${p.player}</div>
                                <div class="player-info-team">${p.team}${p.position ? ` ‚Ä¢ ${p.position}` : ''}</div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Age</span>
                                  <span class="player-info-value" style="color: ${getAgeColor(p.age)}">${p.age || 'N/A'}</span>
                                </div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Last 365 days</span>
                                  <span class="player-info-value"><span style="color: ${getRatingColor(p.globalRating)}">${p.globalRating ? p.globalRating.toFixed(1) : 'N/A'} RAT</span>${p.gamesPlayed ? ` ‚Ä¢ <span style="color: ${getGamesColor(p.gamesPlayed)}">${p.gamesPlayed} G</span>` : ''}</span>
                                </div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Contract ends</span>
                                  <span class="player-info-value">${p.contractEnd || 'N/A'}</span>
                                </div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Total Guaranteed</span>
                                  <span class="player-info-value">${formatSalary(p.guaranteedMoney || 0)}</span>
                                </div>
                              </div>
                            </span>
                            ${p.isOut ? `<span class="injury-badge" title="${p.injuryReason || 'Inactive'}">‚úö</span>` : ''}
                            ${isTwoWay ? '<span class="tw-badge" title="Two-Way Contract">TW</span>' : ''}
                            ${p.poisonPill > 0 ? '<span class="pp-badge" title="Poison Pill Provision">PP</span>' : ''}
                            ${p.tradeKicker > 0 ? `<span class="tk-badge" title="Trade Kicker: ${p.tradeKicker}%">TK</span>` : ''}
                            ${p.isMinSalaryException ? '<span class="mse-badge" title="Minimum Salary Exception - No salary matching required">MSE</span>' : ''}
                            ${p.isMinimum && !p.isMinSalaryException ? '<span class="min-badge" title="Minimum Salary">MIN</span>' : ''}
                          </div>
                          <div class="player-chip-salary">${formatSalary(incomingValue)}${showAdjusted ? ` <span style="color: ${adjustedColor}; font-size: 0.7em;">(actual ${formatSalary(p.salary)})</span>` : ''}</div>
                        </div>
                      </div>
                    </div>
                  `;
                }).join('')}
                ${incomingPicks.map(pick => {
                  const isConditional = pick.surePick !== 'YES';
                  // For incoming picks, show the team name if notes is "Own pick" or similar
                  const pickSource = (pick.notes && !pick.notes.toLowerCase().includes('own pick')) 
                    ? pick.notes 
                    : `${pick.fromTeam} pick`;
                  return `
                    <div class="player-chip incoming" style="background: var(--orange-dim); border-color: var(--orange);">
                      <div class="player-chip-row">
                        <div class="player-chip-info">
                          <div class="player-chip-name" style="color: var(--orange);">
                            üìã ${pick.year} ${pick.round} Round Pick
                            ${isConditional ? `<span class="pick-conditional" title="${pick.notes || 'Conditional pick'}">COND</span>` : ''}
                          </div>
                          <div class="player-chip-salary" style="font-size: 0.7em; color: var(--text-secondary);">${pickSource}</div>
                        </div>
                      </div>
                    </div>
                  `;
                }).join('')}
                ${incomingRights.map(rights => {
                  return `
                    <div class="player-chip incoming" style="background: rgba(168, 85, 247, 0.15); border-color: #a855f7;">
                      <div class="player-chip-row">
                        <div class="player-chip-info">
                          <div class="player-chip-name" style="color: #a855f7;">
                            üéì Rights to ${rights.playerName}
                          </div>
                          <div class="player-chip-salary" style="font-size: 0.7em; color: var(--text-secondary);">Drafted ${rights.draftedYear} (from ${rights.fromTeam})</div>
                        </div>
                      </div>
                    </div>
                  `;
                }).join('')}
                ${incomingCash > 0 ? Array(incomingCash).fill(0).map(() => `
                  <div class="player-chip incoming" style="background: rgba(34, 197, 94, 0.15); border-color: #22c55e;">
                    <div class="player-chip-row">
                      <div class="player-chip-info">
                        <div class="player-chip-name" style="color: #22c55e;">
                          üíµ Cash Considerations
                        </div>
                      </div>
                    </div>
                  </div>
                `).join('') : ''}
              </div>
            `;
            })()}
            
            ${tradeTeam.teamName && (tradeTeam.playersOut.length > 0 || tradeTeam.playersIn.length > 0) ? `
              <div class="team-footer">
                ${teamInfo ? `
                  <div class="team-status" style="margin-bottom: 0.75rem;">
                    <span class="team-status-item">
                      <strong>${teamInfo.status}</strong>${(() => {
                        // Calculate post-trade status
                        const outSal = tradeTeam.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
                        const inSal = tradeTeam.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
                        const netIn = inSal - outSal;
                        
                        if (netIn === 0) return '';
                        
                        const status = teamInfo.status.toUpperCase();
                        let newStatus = null;
                        let color = 'var(--orange)';
                        
                        if (netIn > 0) {
                          if (status === 'BELOW TAX') {
                            if (teamInfo.apronRoom2nd > 0 && netIn > teamInfo.apronRoom2nd) {
                              newStatus = '2nd Apron';
                            } else if (teamInfo.apronRoom1st > 0 && netIn > teamInfo.apronRoom1st) {
                              newStatus = '1st Apron';
                            } else if (teamInfo.taxRoom > 0 && netIn > teamInfo.taxRoom) {
                              newStatus = 'Tax Team';
                            }
                          } else if (status === 'TAX TEAM') {
                            if (teamInfo.apronRoom2nd > 0 && netIn > teamInfo.apronRoom2nd) {
                              newStatus = '2nd Apron';
                            } else if (teamInfo.apronRoom1st > 0 && netIn > teamInfo.apronRoom1st) {
                              newStatus = '1st Apron';
                            }
                          } else if (status === '1ST APRON') {
                            if (teamInfo.apronRoom2nd > 0 && netIn > teamInfo.apronRoom2nd) {
                              newStatus = '2nd Apron';
                            }
                          }
                        } else {
                          const netOut = Math.abs(netIn);
                          color = 'var(--valid)';
                          
                          if (status === '2ND APRON') {
                            if (teamInfo.apronRoom2nd < 0 && netOut > Math.abs(teamInfo.apronRoom2nd)) {
                              if (teamInfo.apronRoom1st < 0 && netOut > Math.abs(teamInfo.apronRoom1st)) {
                                if (teamInfo.taxRoom < 0 && netOut > Math.abs(teamInfo.taxRoom)) {
                                  newStatus = 'Below Tax';
                                } else {
                                  newStatus = 'Tax Team';
                                }
                              } else {
                                newStatus = '1st Apron';
                              }
                            }
                          } else if (status === '1ST APRON') {
                            if (teamInfo.apronRoom1st < 0 && netOut > Math.abs(teamInfo.apronRoom1st)) {
                              if (teamInfo.taxRoom < 0 && netOut > Math.abs(teamInfo.taxRoom)) {
                                newStatus = 'Below Tax';
                              } else {
                                newStatus = 'Tax Team';
                              }
                            }
                          } else if (status === 'TAX TEAM') {
                            if (teamInfo.taxRoom < 0 && netOut > Math.abs(teamInfo.taxRoom)) {
                              newStatus = 'Below Tax';
                            }
                          }
                        }
                        
                        if (newStatus) {
                          return ` <span style="color: ${color};">‚Üí ${newStatus}</span>`;
                        }
                        return '';
                      })()}
                    </span>
                    ${teamInfo.isHardcap1st ? `<span class="team-status-item" style="color: var(--orange);">Hard Capped 1st Apron</span>` : ''}
                    ${teamInfo.isHardcap2nd ? `<span class="team-status-item" style="color: var(--orange);">Hard Capped 2nd Apron</span>` : ''}
                  </div>
                ` : ''}
                <div class="salary-summary">
                  <div class="salary-row">
                    <span class="salary-label">Outgoing</span>
                    <span class="salary-value">${formatSalary(outgoingSalary)}</span>
                  </div>
                  <div class="salary-row">
                    <span class="salary-label">Incoming</span>
                    <span class="salary-value">${formatSalary(incomingSalary)}</span>
                  </div>
                  ${tradeTeam.tpeUsed ? `
                    <div class="salary-row">
                      <span class="salary-label">TPE Used</span>
                      <span class="salary-value" style="color: var(--green);">${formatSalary(Math.min(tradeTeam.tpeUsed.value, incomingSalary))}</span>
                    </div>
                  ` : ''}
                  <div class="salary-row total">
                    <span class="salary-label">Net</span>
                    <span class="salary-value ${netSalary > 0 ? 'negative' : netSalary < 0 ? 'positive' : ''}">${netSalary > 0 ? '+' : ''}${formatSalary(netSalary)}</span>
                  </div>
                  ${teamInfo ? (() => {
                    const capSpaceValue = teamInfo.capSpace || 0;
                    const postTradeCapSpace = capSpaceValue - netSalary;
                    const postTradeTaxRoom = (teamInfo.taxRoom || 0) - netSalary;
                    const postTradeApron1st = (teamInfo.apronRoom1st || 0) - netSalary;
                    const postTradeApron2nd = (teamInfo.apronRoom2nd || 0) - netSalary;
                    
                    return `
                      <div class="salary-row" style="margin-top: 0.5rem; border-top: 1px solid var(--border); padding-top: 0.5rem;">
                        <span class="salary-label">Cap Space</span>
                        <span class="salary-value ${postTradeCapSpace < 0 ? 'negative' : 'positive'}">${postTradeCapSpace >= 0 ? '' : '-'}${formatSalary(Math.abs(postTradeCapSpace))}</span>
                      </div>
                      <div class="salary-row">
                        <span class="salary-label">Tax Room</span>
                        <span class="salary-value ${postTradeTaxRoom < 0 ? 'negative' : 'positive'}">${postTradeTaxRoom >= 0 ? '' : '-'}${formatSalary(Math.abs(postTradeTaxRoom))}</span>
                      </div>
                      <div class="salary-row">
                        <span class="salary-label">1st Apron</span>
                        <span class="salary-value ${postTradeApron1st < 0 ? 'negative' : 'positive'}">${postTradeApron1st >= 0 ? '' : '-'}${formatSalary(Math.abs(postTradeApron1st))}</span>
                      </div>
                      <div class="salary-row">
                        <span class="salary-label">2nd Apron</span>
                        <span class="salary-value ${postTradeApron2nd < 0 ? 'negative' : 'positive'}">${postTradeApron2nd >= 0 ? '' : '-'}${formatSalary(Math.abs(postTradeApron2nd))}</span>
                      </div>
                    `;
                  })() : ''}
                </div>
                ${validation && !validation.valid ? `
                  <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--red);">
                    ‚ö†Ô∏è ${validation.message}
                  </div>
                ` : ''}
                ${validation && validation.warnings && validation.warnings.length > 0 ? `
                  <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--orange);">
                    ‚ö†Ô∏è ${validation.warnings.join('; ')}
                  </div>
                ` : ''}
              </div>
            ` : ''}
            </div>
              
            ${tradeTeam.teamName ? `
              <div class="roster-section${!isTradeValid ? ' expanded' : ''}">
                <div class="section-label">Roster</div>
                <div class="player-roster" data-team="${index}">
                  ${getTeamPlayers(tradeTeam.teamName)
                    .sort((a, b) => b.salary - a.salary)
                    .map(p => {
                      const isAdded = tradeTeam.playersOut.some(po => po.player === p.player);
                      const isTwoWay = p.contractStatus?.toUpperCase() === 'TWO-WAY';
                      const is10Day = p.is10Day || p.contractStatus?.toUpperCase().includes('10-DAY');
                      const isUnavailable = is10Day || p.tradeAvailable?.toLowerCase() === 'not available';
                      const isDisabled = isAdded || isUnavailable;
                      return `
                        <div class="player-roster-item ${isDisabled ? 'disabled' : ''}" data-team="${index}" data-player="${p.player}" ${isDisabled ? 'data-disabled="true"' : ''}>
                          ${p.headshot ? `<img src="${p.headshot}" class="roster-headshot" alt="" onerror="this.style.display='none'">` : '<div class="roster-headshot-placeholder"></div>'}
                          <span class="player-roster-name">
                            ${p.player}
                            <span class="player-info-wrapper">
                              <span class="player-info-icon">‚Ñπ</span>
                              <div class="player-info-tooltip">
                                <div class="player-info-name">${p.player}</div>
                                <div class="player-info-team">${p.team}${p.position ? ` ‚Ä¢ ${p.position}` : ''}</div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Age</span>
                                  <span class="player-info-value" style="color: ${getAgeColor(p.age)}">${p.age || 'N/A'}</span>
                                </div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Last 365 days</span>
                                  <span class="player-info-value"><span style="color: ${getRatingColor(p.globalRating)}">${p.globalRating ? p.globalRating.toFixed(1) : 'N/A'} RAT</span>${p.gamesPlayed ? ` ‚Ä¢ <span style="color: ${getGamesColor(p.gamesPlayed)}">${p.gamesPlayed} G</span>` : ''}</span>
                                </div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Contract ends</span>
                                  <span class="player-info-value">${p.contractEnd || 'N/A'}</span>
                                </div>
                                <div class="player-info-row">
                                  <span class="player-info-label">Total Guaranteed</span>
                                  <span class="player-info-value">${formatSalary(p.guaranteedMoney || 0)}</span>
                                </div>
                                ${(() => {
                                  const tradePct = getPlayerTradePercentage(p.playerId);
                                  if (tradePct > 0) {
                                    return `<div class="player-info-row">
                                      <span class="player-info-label">Trade Activity</span>
                                      <span class="player-info-value" style="color: ${tradePct >= 3 ? '#ef4444' : '#6366f1'}">${tradePct}% of trades</span>
                                    </div>`;
                                  }
                                  return '';
                                })()}
                                ${p.noTradeTo ? `<div class="player-info-row">
                                  <span class="player-info-label">Can't trade to</span>
                                  <span class="player-info-value" style="color: #ef4444">${p.noTradeTo}</span>
                                </div>` : ''}
                              </div>
                            </span>
                            ${p.isOut ? `<span class="injury-badge" title="${p.injuryReason || 'Inactive'}">‚úö</span>` : ''}
                            ${isTwoWay ? '<span class="tw-badge" title="Two-Way Contract">TW</span>' : ''}
                            ${is10Day ? '<span class="tw-badge" title="10-Day Contract" style="background: rgba(239, 68, 68, 0.15); color: #ef4444;">10D</span>' : ''}
                            ${p.noTradeClause ? '<span class="ntc-badge" title="No-Trade Clause">NTC</span>' : ''}
                            ${p.notAggregated ? '<span class="na-badge" title="Can\'t be aggregated">NA</span>' : ''}
                            ${p.poisonPill > 0 ? '<span class="pp-badge" title="Poison Pill Provision">PP</span>' : ''}
                            ${p.tradeKicker > 0 ? `<span class="tk-badge" title="Trade Kicker: ${p.tradeKicker}%">TK</span>` : ''}
                            ${p.isMinSalaryException ? '<span class="mse-badge" title="Minimum Salary Exception - No salary matching required">MSE</span>' : ''}
                            ${p.isMinimum && !p.isMinSalaryException ? '<span class="min-badge" title="Minimum Salary">MIN</span>' : ''}
                            ${p.tradeAvailable && !is10Day ? '<span class="restriction-badge" title="Trade Restriction">!</span>' : ''}
                            ${(() => {
                              const pct = getPlayerTradePercentage(p.playerId);
                              if (pct >= 3) {
                                return `<span class="trending-badge" title="Trending: Appears in ${pct}% of trades">üî•</span>`;
                              }
                              return '';
                            })()}
                          </span>
                          <span class="player-roster-salary">${formatSalary(p.salary)}</span>
                        </div>
                      `;
                    }).join('')}
                </div>
                ${(() => {
                  const teamTPEs = getTeamTPEs(tradeTeam.teamName);
                  if (teamTPEs.length === 0) return '';
                  
                  // Check if team is 1st or 2nd Apron (can't use TPEs)
                  const teamInfo = getTeamInfo(tradeTeam.teamName);
                  const teamStatus = teamInfo?.status?.toUpperCase() || '';
                  const isApronTeam = teamStatus.includes('1ST APRON') || teamStatus.includes('2ND APRON');
                  
                  return `
                    <div class="tpe-section" ${isApronTeam ? 'style="opacity: 0.5;"' : ''}>
                      <div class="tpe-section-header">
                        <span class="tpe-label">Trade Exceptions</span>
                        ${isApronTeam ? '<span class="tpe-used-badge" style="background: var(--red-dim); color: var(--red);">APRON - CAN\'T USE</span>' : ''}
                        ${!isApronTeam && tradeTeam.tpeUsed ? '<span class="tpe-used-badge">TPE IN USE</span>' : ''}
                      </div>
                      <div class="tpe-list">
                        ${teamTPEs.map((tpe, tpeIndex) => {
                          const isSelected = tradeTeam.tpeUsed && tradeTeam.tpeUsed.value === tpe.value && tradeTeam.tpeUsed.expirationDate === tpe.expirationDate;
                          const isUsedElsewhere = tradeTeams.some((t, i) => i !== index && t.tpeUsed && t.tpeUsed.value === tpe.value && t.tpeUsed.team === tpe.team);
                          const isDisabled = isUsedElsewhere || isApronTeam;
                          return `
                            <div class="tpe-item ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}" 
                                 data-team="${index}" 
                                 data-tpe-index="${tpeIndex}"
                                 data-tpe-value="${tpe.value}"
                                 data-tpe-date="${tpe.expirationDate}"
                                 ${isDisabled ? 'data-disabled="true"' : ''}>
                              <div>
                                <span class="tpe-value">${formatSalary(tpe.value)}</span>
                                ${tpe.expirationDate ? `<span class="tpe-expiry">expires ${tpe.expirationDate}</span>` : ''}
                              </div>
                              ${isSelected ? '<span style="color: var(--green);">‚úì</span>' : ''}
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                })()}
                ${(() => {
                  const teamPicks = getTeamDraftPicks(tradeTeam.teamName);
                  if (teamPicks.length === 0) return '';
                  const picksOut = tradeTeam.picksOut || [];
                  return `
                    <div class="picks-section">
                      <div class="picks-section-header">
                        <span class="picks-label">Draft Picks</span>
                        ${picksOut.length > 0 ? '<span class="picks-traded-badge">PICKS TRADED</span>' : ''}
                      </div>
                      <div class="picks-list">
                        ${teamPicks.map((pick, pickIndex) => {
                          // Use pickIndex as unique identifier since same team can have multiple picks in same year
                          const isSelected = picksOut.some(p => p.pickIndex === pickIndex);
                          const isUsedElsewhere = tradeTeams.some((t, i) => i !== index && (t.picksOut || []).some(p => p.team === pick.team && p.pickIndex === pickIndex));
                          const isConditional = pick.surePick !== 'YES';
                          return `
                            <div class="pick-item ${isSelected ? 'selected' : ''} ${isUsedElsewhere ? 'disabled' : ''}" 
                                 data-team="${index}" 
                                 data-pick-index="${pickIndex}"
                                 data-pick-year="${pick.year}"
                                 data-pick-round="${pick.round}"
                                 data-pick-team="${pick.team}"
                                 data-pick-notes="${pick.notes || ''}"
                                 data-pick-sure="${pick.surePick}"
                                 data-pick-linked="${pick.linkedTo || ''}"
                                 ${isUsedElsewhere ? 'data-disabled="true"' : ''}
                                 title="${pick.notes || `${pick.year} ${pick.round} Round Pick`}">
                              <div>
                                <span class="pick-year">${pick.year}</span>
                                <span class="pick-round">${pick.round}</span>
                                ${isConditional ? `<span class="pick-conditional" title="${pick.notes || 'Conditional pick'}">COND</span>` : ''}
                              </div>
                              <div style="display: flex; align-items: center; gap: 0.25rem;">
                                ${pick.notes ? `<span class="pick-notes">${pick.notes}</span>` : ''}
                                ${isSelected ? '<span style="color: var(--orange);">‚úì</span>' : ''}
                              </div>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                })()}
                ${(() => {
                  const teamRights = getTeamDraftRights(tradeTeam.teamName);
                  if (teamRights.length === 0) return '';
                  const rightsOut = tradeTeam.rightsOut || [];
                  return `
                    <div class="rights-section">
                      <div class="rights-section-header">
                        <span class="rights-label">Draft Rights</span>
                        ${rightsOut.length > 0 ? '<span class="rights-traded-badge">RIGHTS TRADED</span>' : ''}
                      </div>
                      <div class="rights-list">
                        ${teamRights.map((rights, rightsIndex) => {
                          const isSelected = rightsOut.some(r => r.playerName === rights.playerName);
                          const isUsedElsewhere = tradeTeams.some((t, i) => i !== index && (t.rightsOut || []).some(r => r.playerName === rights.playerName && r.team === rights.team));
                          return `
                            <div class="rights-item ${isSelected ? 'selected' : ''} ${isUsedElsewhere ? 'disabled' : ''}" 
                                 data-team="${index}" 
                                 data-rights-index="${rightsIndex}"
                                 data-rights-player="${rights.playerName}"
                                 data-rights-year="${rights.draftedYear}"
                                 data-rights-team="${rights.team}"
                                 ${isUsedElsewhere ? 'data-disabled="true"' : ''}
                                 title="Draft rights to ${rights.playerName} (${rights.draftedYear})">
                              <div>
                                <span class="rights-name">${rights.playerName}</span>
                                <span class="rights-year">(${rights.draftedYear})</span>
                              </div>
                              ${isSelected ? '<span style="color: #a855f7;">‚úì</span>' : ''}
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                })()}
                <div class="cash-section">
                  <div class="cash-label">Cash Considerations</div>
                  <div class="cash-item" 
                       data-team="${index}"
                       data-cash="add">
                    <span>üíµ + Add Cash Considerations</span>
                  </div>
                </div>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    // Render add team card
    function renderAddTeamCard() {
      if (tradeTeams.length >= MAX_TEAMS) return '';
      return `
        <div class="add-team-card" id="addTeamCard">
          <div class="add-team-content">
            <div class="add-team-icon">+</div>
            <div class="add-team-text">Add Team</div>
          </div>
        </div>
      `;
    }

    // Render trade status
    function renderTradeStatus() {
      const validation = validateTrade();
      
      // Show status if any assets are being traded (players, picks, rights, or cash)
      const hasAnyAssets = tradeTeams.some(t => 
        t.playersOut.length > 0 || 
        (t.picksOut && t.picksOut.length > 0) ||
        (t.rightsOut && t.rightsOut.length > 0) ||
        (t.cashOut && t.cashOut.length > 0)
      );
      
      if (!hasAnyAssets) {
        tradeStatus.style.display = 'none';
        const checkRumorsLink = document.getElementById('checkRumorsLink');
        if (checkRumorsLink) checkRumorsLink.style.display = 'none';
        return;
      }

      tradeStatus.style.display = 'flex';
      tradeStatus.className = 'trade-status ' + (validation.type.startsWith('pending') ? 'pending' : validation.type);
      
      document.getElementById('tradeStatusIcon').textContent = 
        validation.type === 'valid' ? '‚úì' : 
        validation.type.startsWith('pending') ? '‚úì' :
        validation.type === 'warning' ? '‚ö†Ô∏è' : '‚úó';
      
      let statusTitle;
      if (validation.type === 'valid') {
        statusTitle = 'Trade is valid';
      } else if (validation.type === 'pending-date') {
        statusTitle = `Trade will be valid on ${validation.pendingDate}`;
      } else if (validation.type === 'pending-ntc') {
        const ntcCount = (validation.message.match(/no-trade clause/g) || []).length;
        statusTitle = ntcCount > 1 ? 'Trade is valid (pending players approval)' : 'Trade is valid (pending player approval)';
      } else if (validation.type === 'pending-both') {
        const ntcCount = (validation.message.match(/no-trade clause/g) || []).length;
        const approvalText = ntcCount > 1 ? 'pending players approval' : 'pending player approval';
        statusTitle = `Trade will be valid on ${validation.pendingDate} (${approvalText})`;
      } else if (validation.type === 'warning') {
        statusTitle = 'Trade has warnings';
      } else {
        statusTitle = 'Trade is invalid';
      }
      
      document.getElementById('tradeStatusTitle').textContent = statusTitle;
      
      document.getElementById('tradeStatusMessage').textContent = validation.message;
      
      // Track completed/valid trade
      if (validation.valid || validation.type?.startsWith('pending')) {
        const playerIds = [];
        tradeTeams.forEach(t => {
          if (t.playersOut) {
            t.playersOut.forEach(p => {
              if (p.playerId) playerIds.push(p.playerId);
            });
          }
        });
        if (playerIds.length > 0) {
          trackCompletedTrade(playerIds);
        }
      }
      
      // Show/hide Check Rumors link based on whether there are players in the trade
      const checkRumorsLink = document.getElementById('checkRumorsLink');
      const hasPlayersInTrade = tradeTeams.some(t => t.playersOut && t.playersOut.length > 0);
      if (checkRumorsLink) {
        checkRumorsLink.style.display = hasPlayersInTrade ? 'block' : 'none';
      }
    }

    // Main render function
    function render() {
      tradeContainer.innerHTML = tradeTeams.map((t, i) => renderTeamCard(t, i)).join('') + renderAddTeamCard();
      renderTradeStatus();
      attachEventListeners();
      equalizeTradeContentHeights();
      updateUrlAndTitle(); // Update URL and page title based on trade
      
      // Defer rumors loading to not block initial render
      if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(() => displayTradeRumors(), { timeout: 500 });
      } else {
        setTimeout(() => displayTradeRumors(), 100);
      }
    }
    
    // Update URL and page title based on current trade
    function updateUrlAndTitle() {
      // Collect all players being traded for URL
      const allPlayersOut = [];
      const allTeams = new Set();
      const allPicks = [];
      const allRights = [];
      const allCash = [];
      
      tradeTeams.forEach((team, teamIndex) => {
        if (team.teamName) allTeams.add(team.teamName);
        if (team.playersOut && team.playersOut.length > 0) {
          team.playersOut.forEach(p => {
            allPlayersOut.push({
              name: p.player,
              fromTeamIndex: teamIndex,
              destination: p.destination
            });
          });
        }
        // Collect picks
        if (team.picksOut && team.picksOut.length > 0) {
          team.picksOut.forEach(pick => {
            allPicks.push({
              fromTeamIndex: teamIndex,
              pickTeam: pick.team,
              year: pick.year,
              round: pick.round,
              destination: pick.destination
            });
          });
        }
        // Collect draft rights
        if (team.rightsOut && team.rightsOut.length > 0) {
          team.rightsOut.forEach(rights => {
            allRights.push({
              fromTeamIndex: teamIndex,
              playerName: rights.playerName,
              destination: rights.destination
            });
          });
        }
        // Collect cash (no amount, just destination)
        if (team.cashOut && team.cashOut.length > 0) {
          team.cashOut.forEach(cash => {
            allCash.push({
              fromTeamIndex: teamIndex,
              destination: cash.destination
            });
          });
        }
      });
      
      // Update page title based on trade
      if (allPlayersOut.length > 0 || allPicks.length > 0 || allRights.length > 0) {
        // Get first few player last names for title
        const playerNames = allPlayersOut.slice(0, 3).map(p => {
          const parts = p.name.split(' ');
          return parts[parts.length - 1]; // Last name
        });
        
        let titleParts = [];
        
        if (playerNames.length > 0) {
          if (allPlayersOut.length > 3) {
            titleParts.push(`${playerNames.join(', ')} +${allPlayersOut.length - 3}`);
          } else {
            titleParts.push(playerNames.join(', '));
          }
        }
        
        // Add pick count if present
        if (allPicks.length > 0) {
          titleParts.push(`${allPicks.length} pick${allPicks.length > 1 ? 's' : ''}`);
        }
        
        // Add rights count if present
        if (allRights.length > 0 && playerNames.length === 0) {
          titleParts.push(`${allRights.length} draft right${allRights.length > 1 ? 's' : ''}`);
        }
        
        document.title = titleParts.length > 0 ? `Trade Machine - ${titleParts.join(' + ')}` : 'NBA Trade Machine';
      } else {
        document.title = 'NBA Trade Machine';
      }
      
      // Check if this is a loop URL - don't modify those
      if (IS_LOOP_URL) {
        return; // Don't modify loop URLs
      }
      
      // If no players in trade, reset URL
      if (allPlayersOut.length === 0) {
        if (window.location.search) {
          window.history.replaceState({}, '', window.location.pathname);
        }
        return;
      }
      
      // Get player objects to access IDs
      const getPlayerById = (name) => players.find(p => p.player === name);
      
      // Use compact format: player IDs and team abbreviations
      const playerIds = allPlayersOut.slice(0, 8).map(p => {
        const playerObj = getPlayerById(p.name);
        return playerObj?.playerId || p.name.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
      });
      
      const teamAbbrevs = Array.from(allTeams).slice(0, 5).map(name =>
        teamAbbreviations[name] || name.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '')
      );
      
      const params = new URLSearchParams();
      if (playerIds.length > 0) params.set('p', playerIds.join(','));
      if (teamAbbrevs.length > 0) params.set('t', teamAbbrevs.join(','));
      
      // Encode player destinations (format: fromTeamIdx-destIdx,fromTeamIdx-destIdx,...)
      const playerDests = allPlayersOut.slice(0, 8).map(p => 
        `${p.fromTeamIndex}-${p.destination !== undefined ? p.destination : ''}`
      );
      if (playerDests.some(d => d.includes('-') && d.split('-')[1] !== '')) {
        params.set('pd', playerDests.join(','));
      }
      
      // Encode picks (format: fromTeamIdx:pickTeamAbbrev:year:round:destIdx,...)
      if (allPicks.length > 0) {
        const pickStrings = allPicks.slice(0, 6).map(pick => {
          const pickTeamAbbrev = teamAbbreviations[pick.pickTeam] || pick.pickTeam.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
          // Use short round format: 1 or 2 instead of 1st or 2nd
          const roundShort = pick.round === '1st' ? '1' : '2';
          return `${pick.fromTeamIndex}:${pickTeamAbbrev}:${pick.year}:${roundShort}:${pick.destination !== undefined ? pick.destination : ''}`;
        });
        params.set('pk', pickStrings.join(','));
      }
      
      // Encode draft rights (format: fromTeamIdx:playerName:destIdx,...)
      if (allRights.length > 0) {
        const rightsStrings = allRights.slice(0, 4).map(rights => {
          const playerSlug = rights.playerName.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
          return `${rights.fromTeamIndex}:${playerSlug}:${rights.destination !== undefined ? rights.destination : ''}`;
        });
        params.set('r', rightsStrings.join(','));
      }
      
      // Encode cash (format: fromTeamIdx:destIdx,...)
      if (allCash.length > 0) {
        const cashStrings = allCash.slice(0, 4).map(cash => 
          `${cash.fromTeamIndex}:${cash.destination !== undefined ? cash.destination : ''}`
        );
        params.set('c', cashStrings.join(','));
      }
      
      const newUrl = `${window.location.pathname}?${params.toString()}`;
      window.history.replaceState({}, '', newUrl);
    }

    // Equalize trade content heights so roster sections align
    function equalizeTradeContentHeights() {
      const tradeContents = document.querySelectorAll('.trade-content');
      if (tradeContents.length === 0) return;
      
      // Reset heights first
      tradeContents.forEach(el => el.style.minHeight = '');
      
      // Find the maximum height
      let maxHeight = 0;
      tradeContents.forEach(el => {
        const height = el.offsetHeight;
        if (height > maxHeight) maxHeight = height;
      });
      
      // Set all to the maximum height
      tradeContents.forEach(el => {
        el.style.minHeight = maxHeight + 'px';
      });
    }

    // Attach event listeners
    function attachEventListeners() {
      // Team select change
      document.querySelectorAll('.team-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const index = parseInt(e.target.dataset.index);
          tradeTeams[index].teamName = e.target.value;
          tradeTeams[index].playersOut = [];
          tradeTeams[index].playersIn = [];
          tradeTeams[index].tpeUsed = null;
          tradeTeams[index].picksOut = [];
          tradeTeams[index].rightsOut = [];
          tradeTeams[index].cashOut = [];
          
          // Auto-assign destinations for players in other teams that don't have one yet
          const otherTeamsWithPlayers = tradeTeams.filter((t, i) => i !== index && t.teamName && t.playersOut.length > 0);
          if (e.target.value && otherTeamsWithPlayers.length > 0) {
            otherTeamsWithPlayers.forEach(team => {
              team.playersOut.forEach(player => {
                if (player.destination === undefined) {
                  // Assign to this newly selected team
                  player.destination = index;
                }
              });
            });
          }
          
          redistributePlayers();
          render();
        });
      });

      // Remove team
      document.querySelectorAll('.remove-team-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const index = parseInt(e.target.dataset.index);
          tradeTeams.splice(index, 1);
          redistributePlayers();
          render();
        });
      });

      // Remove player
      document.querySelectorAll('.player-chip-remove:not(.pick-remove)').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const playerIndex = parseInt(e.target.dataset.player);
          tradeTeams[teamIndex].playersOut.splice(playerIndex, 1);
          redistributePlayers();
          render();
        });
      });

      // Remove pick
      document.querySelectorAll('.pick-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const pickIndex = parseInt(e.target.dataset.pick);
          tradeTeams[teamIndex].picksOut.splice(pickIndex, 1);
          render();
        });
      });

      // Remove rights
      document.querySelectorAll('.rights-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const rightsIndex = parseInt(e.target.dataset.rights);
          tradeTeams[teamIndex].rightsOut.splice(rightsIndex, 1);
          render();
        });
      });

      // Remove cash
      document.querySelectorAll('.cash-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const cashIndex = parseInt(e.target.dataset.cash);
          tradeTeams[teamIndex].cashOut.splice(cashIndex, 1);
          render();
        });
      });

      // Player destination change
      document.querySelectorAll('.player-destination-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const playerIndex = parseInt(e.target.dataset.player);
          const destinationIndex = e.target.value ? parseInt(e.target.value) : undefined;
          tradeTeams[teamIndex].playersOut[playerIndex].destination = destinationIndex;
          redistributePlayers();
          render();
        });
      });

      // Pick destination change
      document.querySelectorAll('.pick-destination-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const pickIndex = parseInt(e.target.dataset.pick);
          const destinationIndex = e.target.value ? parseInt(e.target.value) : undefined;
          tradeTeams[teamIndex].picksOut[pickIndex].destination = destinationIndex;
          render();
        });
      });

      // Rights destination change
      document.querySelectorAll('.rights-destination-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const rightsIndex = parseInt(e.target.dataset.rights);
          const destinationIndex = e.target.value ? parseInt(e.target.value) : undefined;
          tradeTeams[teamIndex].rightsOut[rightsIndex].destination = destinationIndex;
          render();
        });
      });

      // Cash destination change
      document.querySelectorAll('.cash-destination-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const teamIndex = parseInt(e.target.dataset.team);
          const cashIndex = parseInt(e.target.dataset.cash);
          const destinationIndex = e.target.value ? parseInt(e.target.value) : undefined;
          tradeTeams[teamIndex].cashOut[cashIndex].destination = destinationIndex;
          render();
        });
      });

      // Add team
      const addTeamCard = document.getElementById('addTeamCard');
      if (addTeamCard) {
        addTeamCard.addEventListener('click', () => {
          tradeTeams.push({ teamName: '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] });
          render();
        });
      }

      // Player roster click
      document.querySelectorAll('.player-roster-item').forEach(item => {
        item.addEventListener('click', () => {
          if (item.dataset.disabled === 'true') return;
          
          const teamIndex = parseInt(item.dataset.team);
          const playerName = item.dataset.player;
          const teamName = tradeTeams[teamIndex].teamName;
          const teamPlayers = getTeamPlayers(teamName);
          const player = teamPlayers.find(p => p.player === playerName);
          
          if (player) {
            // Create a copy of the player with destination property
            const playerWithDest = { ...player };
            
            // Auto-assign destination for 2-team trades
            const otherTeams = getOtherActiveTeams(teamIndex);
            if (otherTeams.length === 1) {
              playerWithDest.destination = otherTeams[0].index;
            }
            
            tradeTeams[teamIndex].playersOut.push(playerWithDest);
            
            // Track player trade count
            incrementPlayerTradeCount(player.playerId, player.player);
            
            redistributePlayers();
            render();
          }
        });
      });

      // TPE click - toggle selection
      document.querySelectorAll('.tpe-item').forEach(item => {
        item.addEventListener('click', () => {
          if (item.dataset.disabled === 'true') return;
          
          const teamIndex = parseInt(item.dataset.team);
          const tpeValue = parseSalary(item.dataset.tpeValue);
          const tpeDate = item.dataset.tpeDate;
          const teamName = tradeTeams[teamIndex].teamName;
          
          // Toggle TPE selection
          if (tradeTeams[teamIndex].tpeUsed && 
              tradeTeams[teamIndex].tpeUsed.value === tpeValue &&
              tradeTeams[teamIndex].tpeUsed.expirationDate === tpeDate) {
            // Deselect
            tradeTeams[teamIndex].tpeUsed = null;
          } else {
            // Select this TPE
            tradeTeams[teamIndex].tpeUsed = {
              team: teamName,
              value: tpeValue,
              expirationDate: tpeDate
            };
          }
          
          render();
        });
      });

      // Draft Picks click - toggle selection
      document.querySelectorAll('.pick-item').forEach(item => {
        item.addEventListener('click', () => {
          if (item.dataset.disabled === 'true') return;
          
          const teamIndex = parseInt(item.dataset.team);
          const pickYear = item.dataset.pickYear;
          const pickRound = item.dataset.pickRound;
          const pickTeam = item.dataset.pickTeam;
          const pickNotes = item.dataset.pickNotes;
          const pickLinked = item.dataset.pickLinked;
          
          // Initialize picksOut array if needed
          if (!tradeTeams[teamIndex].picksOut) {
            tradeTeams[teamIndex].picksOut = [];
          }
          
          const pickIndex = parseInt(item.dataset.pickIndex);
          const pickSure = item.dataset.pickSure;
          
          // Toggle pick selection using pickIndex as unique identifier
          const existingIndex = tradeTeams[teamIndex].picksOut.findIndex(
            p => p.pickIndex === pickIndex
          );
          
          if (existingIndex >= 0) {
            // Deselect - remove from array
            tradeTeams[teamIndex].picksOut.splice(existingIndex, 1);
          } else {
            // Select - add to array with default destination
            // Default to the other team in 2-team trade, or first other team in multi-team
            const otherTeamIndex = tradeTeams.findIndex((t, i) => i !== teamIndex && t.teamName);
            tradeTeams[teamIndex].picksOut.push({
              team: pickTeam,
              year: pickYear,
              round: pickRound,
              notes: pickNotes,
              pickIndex: pickIndex,
              surePick: pickSure,
              linkedTo: pickLinked,
              destination: otherTeamIndex >= 0 ? otherTeamIndex : undefined
            });
          }
          
          render();
        });
      });

      // Draft Rights click - toggle selection
      document.querySelectorAll('.rights-item').forEach(item => {
        item.addEventListener('click', () => {
          if (item.dataset.disabled === 'true') return;
          
          const teamIndex = parseInt(item.dataset.team);
          const rightsPlayer = item.dataset.rightsPlayer;
          const rightsYear = item.dataset.rightsYear;
          const rightsTeam = item.dataset.rightsTeam;
          
          // Initialize rightsOut array if needed
          if (!tradeTeams[teamIndex].rightsOut) {
            tradeTeams[teamIndex].rightsOut = [];
          }
          
          // Toggle rights selection
          const existingIndex = tradeTeams[teamIndex].rightsOut.findIndex(
            r => r.playerName === rightsPlayer
          );
          
          if (existingIndex >= 0) {
            // Deselect - remove from array
            tradeTeams[teamIndex].rightsOut.splice(existingIndex, 1);
          } else {
            // Select - add to array with default destination
            const otherTeamIndex = tradeTeams.findIndex((t, i) => i !== teamIndex && t.teamName);
            tradeTeams[teamIndex].rightsOut.push({
              team: rightsTeam,
              playerName: rightsPlayer,
              draftedYear: rightsYear,
              destination: otherTeamIndex >= 0 ? otherTeamIndex : undefined
            });
          }
          
          render();
        });
      });

      // Cash click - add cash consideration
      document.querySelectorAll('.cash-item').forEach(item => {
        item.addEventListener('click', () => {
          const teamIndex = parseInt(item.dataset.team);
          // Initialize cashOut array if needed
          if (!tradeTeams[teamIndex].cashOut) {
            tradeTeams[teamIndex].cashOut = [];
          }
          // Add new cash consideration with default destination
          const otherTeamIndex = tradeTeams.findIndex((t, i) => i !== teamIndex && t.teamName);
          tradeTeams[teamIndex].cashOut.push({ destination: otherTeamIndex >= 0 ? otherTeamIndex : undefined });
          render();
        });
      });

      // Roster section toggle (mobile)
      document.querySelectorAll('.roster-section .section-label').forEach(label => {
        label.addEventListener('click', () => {
          const rosterSection = label.closest('.roster-section');
          if (rosterSection) {
            rosterSection.classList.toggle('expanded');
          }
        });
      });
    }

    // Check if a player can be traded to a specific team
    function canTradePlayerToTeam(player, destTeamName) {
      if (!player.noTradeTo || !destTeamName) return true;
      const restrictedTeams = player.noTradeTo.split(',').map(t => t.trim().toLowerCase());
      const destLower = destTeamName.toLowerCase();
      return !restrictedTeams.some(rt => destLower.includes(rt) || rt.includes(destLower));
    }

    // Generate a random valid trade
    function generateRandomTrade() {
      const MIN_COMBINED_SALARY = 10000000; // $10M minimum
      const MAX_ATTEMPTS = 150;
      
      // Get tradeable players (exclude two-way, 10-day, must have team)
      const tradeablePlayers = players.filter(p => 
        p.team && 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY') &&
        p.tradeAvailable?.toLowerCase() !== 'not available' &&
        p.salary >= 1000000 // At least $1M salary
      );
      
      // Randomly decide 2-team or 3-team trade (40% chance for 3-team)
      const isThreeTeam = Math.random() < 0.4;
      
      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        if (isThreeTeam) {
          // THREE-TEAM TRADE (at least 4 players involved, non-circular allowed)
          // Pick 3 random teams
          const allTeams = [...new Set(tradeablePlayers.map(p => p.team))];
          if (allTeams.length < 3) continue;
          
          const shuffledTeams = [...allTeams].sort(() => Math.random() - 0.5);
          const team1Name = shuffledTeams[0];
          const team2Name = shuffledTeams[1];
          const team3Name = shuffledTeams[2];
          
          // Get players from each team
          const team1Players = tradeablePlayers.filter(p => p.team === team1Name).sort(() => Math.random() - 0.5);
          const team2Players = tradeablePlayers.filter(p => p.team === team2Name).sort(() => Math.random() - 0.5);
          const team3Players = tradeablePlayers.filter(p => p.team === team3Name).sort(() => Math.random() - 0.5);
          
          if (team1Players.length < 2 || team2Players.length < 2 || team3Players.length < 2) continue;
          
          // Create base trade structure
          const testTrade = [
            { 
              teamName: team1Name, 
              playersOut: [], 
              playersIn: [],
              picksOut: [],
              tpeUsed: null,
              rightsOut: [],
              cashOut: []
            },
            { 
              teamName: team2Name, 
              playersOut: [], 
              playersIn: [],
              picksOut: [],
              tpeUsed: null,
              rightsOut: [],
              cashOut: []
            },
            { 
              teamName: team3Name, 
              playersOut: [], 
              playersIn: [],
              picksOut: [],
              tpeUsed: null,
              rightsOut: [],
              cashOut: []
            }
          ];
          
          // Randomly distribute 4-6 players across the trade
          const totalPlayers = 4 + Math.floor(Math.random() * 3); // 4, 5, or 6 players
          let playersAdded = 0;
          
          // Keep track of which players we've used
          const usedPlayers = new Set();
          const playerPools = [team1Players, team2Players, team3Players];
          
          // Add players randomly, with random destinations (not their own team)
          let attempts = 0;
          while (playersAdded < totalPlayers && attempts < 50) {
            attempts++;
            
            // Pick a random team to send from
            const fromTeam = Math.floor(Math.random() * 3);
            const pool = playerPools[fromTeam];
            
            // Find a player we haven't used yet
            const availablePlayer = pool.find(p => !usedPlayers.has(p.player));
            if (!availablePlayer) continue;
            
            // Pick a random destination (not the same team)
            const possibleDests = [0, 1, 2].filter(t => t !== fromTeam);
            const destTeam = possibleDests[Math.floor(Math.random() * possibleDests.length)];
            
            usedPlayers.add(availablePlayer.player);
            testTrade[fromTeam].playersOut.push({ ...availablePlayer, destination: destTeam });
            testTrade[destTeam].playersIn.push(availablePlayer);
            playersAdded++;
          }
          
          // Make sure we have at least 4 players
          if (playersAdded < 4) continue;
          
          // Make sure each team is sending at least one player (true 3-team trade)
          if (testTrade.some(t => t.playersOut.length === 0)) continue;
          
          // Check minimum combined salary
          const totalSalary = testTrade.reduce((sum, t) => 
            sum + t.playersOut.reduce((s, p) => s + p.salary, 0), 0
          );
          if (totalSalary < MIN_COMBINED_SALARY) continue;
          
          // Validate all three sides (salary matching + 2nd Apron restrictions)
          const team1Valid = validateTeamTrade(testTrade[0]);
          const team2Valid = validateTeamTrade(testTrade[1]);
          const team3Valid = validateTeamTrade(testTrade[2]);
          const team1Apron = check2ndApronRestrictions(testTrade[0]);
          const team2Apron = check2ndApronRestrictions(testTrade[1]);
          const team3Apron = check2ndApronRestrictions(testTrade[2]);
          
          if (team1Valid.valid && team2Valid.valid && team3Valid.valid &&
              team1Apron.valid && team2Apron.valid && team3Apron.valid &&
              isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        } else {
          // TWO-TEAM TRADE
          // Pick a random player to start
          const player1 = tradeablePlayers[Math.floor(Math.random() * tradeablePlayers.length)];
          const team1Info = getTeamInfo(player1.team);
          
          // Find potential trade partners from other teams
          const otherTeamPlayers = tradeablePlayers.filter(p => p.team !== player1.team);
          
          // Shuffle and try to find a valid match
          const shuffled = [...otherTeamPlayers].sort(() => Math.random() - 0.5);
          
          for (const player2 of shuffled) {
            const team2Info = getTeamInfo(player2.team);
            
            // Check minimum combined salary
            if (player1.salary + player2.salary < MIN_COMBINED_SALARY) continue;
            
            // Create test trade
            const testTrade = [
              { 
                teamName: player1.team, 
                playersOut: [{ ...player1, destination: 1 }], 
                playersIn: [player2],
                picksOut: [],
                tpeUsed: null,
                rightsOut: [],
                cashOut: []
              },
              { 
                teamName: player2.team, 
                playersOut: [{ ...player2, destination: 0 }], 
                playersIn: [player1],
                picksOut: [],
                tpeUsed: null,
                rightsOut: [],
                cashOut: []
              }
            ];
            
            // Validate both sides (salary matching + 2nd Apron restrictions)
            const team1Valid = validateTeamTrade(testTrade[0]);
            const team2Valid = validateTeamTrade(testTrade[1]);
            const team1Apron = check2ndApronRestrictions(testTrade[0]);
            const team2Apron = check2ndApronRestrictions(testTrade[1]);
            
            if (team1Valid.valid && team2Valid.valid && team1Apron.valid && team2Apron.valid && isTradeValueBalanced(testTrade)) {
              // Maybe add a third player (50% chance) - but only if neither team is 2nd Apron
              const team1Is2ndApron = getTeamInfo(testTrade[0].teamName)?.status?.toUpperCase().includes('2ND APRON');
              const team2Is2ndApron = getTeamInfo(testTrade[1].teamName)?.status?.toUpperCase().includes('2ND APRON');
              
              if (Math.random() > 0.5 && !team1Is2ndApron && !team2Is2ndApron) {
                // Try to add another player to one side
                const sideToAdd = Math.random() > 0.5 ? 0 : 1;
                const teamToAddFrom = testTrade[sideToAdd].teamName;
                const additionalPlayers = tradeablePlayers.filter(p => 
                  p.team === teamToAddFrom && 
                  p.player !== testTrade[sideToAdd].playersOut[0].player &&
                  p.salary < 15000000 // Keep additional player smaller
                );
                
                if (additionalPlayers.length > 0) {
                  const additionalPlayer = additionalPlayers[Math.floor(Math.random() * additionalPlayers.length)];
                  const otherSide = sideToAdd === 0 ? 1 : 0;
                  
                  // Add player and test
                  testTrade[sideToAdd].playersOut.push({ ...additionalPlayer, destination: otherSide });
                  testTrade[otherSide].playersIn.push(additionalPlayer);
                  
                  // Re-validate (including 2nd Apron check and trade value balance)
                  const retest1 = validateTeamTrade(testTrade[0]);
                  const retest2 = validateTeamTrade(testTrade[1]);
                  const retest1Apron = check2ndApronRestrictions(testTrade[0]);
                  const retest2Apron = check2ndApronRestrictions(testTrade[1]);
                  
                  if (!retest1.valid || !retest2.valid || !retest1Apron.valid || !retest2Apron.valid || !isTradeValueBalanced(testTrade)) {
                    // Remove the additional player if it breaks the trade
                    testTrade[sideToAdd].playersOut.pop();
                    testTrade[otherSide].playersIn.pop();
                  }
                }
              }
              
              // Found a valid trade!
              return testTrade;
            }
          }
        }
      }
      
      return null; // No valid trade found
    }

    // Generate a random valid trade featuring a specific player
    function generateTradeForPlayer(playerName) {
      const MAX_ATTEMPTS = 500; // More attempts for hard-to-trade stars
      
      // Find the target player (exact match, case-insensitive)
      const targetPlayer = players.find(p => 
        p.player.toLowerCase() === playerName.toLowerCase()
      );
      
      if (!targetPlayer) {
        return { error: `Player "${playerName}" not found` };
      }
      
      // Check if player is tradeable
      if (targetPlayer.contractStatus?.toUpperCase() === 'TWO-WAY' ||
          targetPlayer.contractStatus?.toUpperCase().includes('10-DAY') ||
          targetPlayer.tradeAvailable?.toLowerCase() === 'not available') {
        return { error: `${targetPlayer.player} is not available for trade` };
      }
      
      const targetTeam = targetPlayer.team;
      
      // Get player's trade value to determine if they're a "star"
      const targetTV = getTradeValue(targetPlayer.player) || targetPlayer.salary;
      const isSuperstar = targetTV > 70000000; // $70M+ TV = superstar (Wemby, etc.)
      const isStar = targetTV > 40000000;       // $40M+ TV = star
      
      // Get tradeable players (exclude two-way, 10-day)
      const tradeablePlayers = players.filter(p => 
        p.team && 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY') &&
        p.tradeAvailable?.toLowerCase() !== 'not available' &&
        p.salary >= 500000
      );
      
      // Get other teams
      const otherTeams = [...new Set(tradeablePlayers.map(p => p.team))].filter(t => t !== targetTeam);
      
      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        // For superstars: heavily prefer 3-team trades (90%)
        // For stars: prefer 3-team trades (70%)
        // For non-stars: normal distribution
        const rand = Math.random();
        let numTeams;
        if (isSuperstar) {
          numTeams = rand < 0.90 ? 3 : rand < 0.95 ? 4 : 2;
        } else if (isStar) {
          numTeams = rand < 0.70 ? 3 : rand < 0.85 ? 2 : 4;
        } else {
          numTeams = rand < 0.6 ? 2 : rand < 0.95 ? 3 : 4;
        }
        
        if (numTeams >= 3 && otherTeams.length >= numTeams - 1) {
          // MULTI-TEAM TRADE (3 or 4 teams)
          const shuffledOtherTeams = [...otherTeams].sort(() => Math.random() - 0.5);
          const involvedTeams = [targetTeam, ...shuffledOtherTeams.slice(0, numTeams - 1)];
          
          // Target player goes to a random other team
          const targetDestination = Math.floor(Math.random() * (numTeams - 1)) + 1;
          const team1PlayersOut = [{ ...targetPlayer, destination: targetDestination }];
          let team1Outgoing = targetPlayer.salary;
          
          // For stars: sometimes add teammates to the package (increases flexibility)
          if ((isSuperstar || isStar) && Math.random() < 0.60) {
            const teammates = tradeablePlayers
              .filter(p => p.team === targetTeam && p.player !== targetPlayer.player)
              .sort(() => Math.random() - 0.5);
            
            // Add 1-3 teammates going to different destinations
            const numTeammates = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < Math.min(numTeammates, teammates.length); i++) {
              const dest = Math.floor(Math.random() * (numTeams - 1)) + 1; // Random other team
              team1PlayersOut.push({ ...teammates[i], destination: dest });
              team1Outgoing += teammates[i].salary;
            }
          }
          
          // Build trade structure
          const testTrade = involvedTeams.map((team, idx) => ({
            teamName: team,
            playersOut: idx === 0 ? team1PlayersOut : [],
            playersIn: [],
            tpeUsed: null,
            picksOut: [],
            rightsOut: [],
            cashOut: []
          }));
          
          // Other teams send players back to team 0 (target team)
          let returnToTeam1 = 0;
          
          for (let teamIdx = 1; teamIdx < numTeams; teamIdx++) {
            // For stars: sort by trade value to get better returns
            let teamPlayers = tradeablePlayers.filter(p => p.team === involvedTeams[teamIdx]);
            if (isSuperstar || isStar) {
              teamPlayers = teamPlayers.sort((a, b) => {
                const tvA = getTradeValue(a.player) || a.salary;
                const tvB = getTradeValue(b.player) || b.salary;
                return tvB - tvA;
              });
            } else {
              teamPlayers = teamPlayers.sort(() => Math.random() - 0.5);
            }
            
            for (const p of teamPlayers) {
              if (returnToTeam1 < team1Outgoing * 1.25 + 5000000) {
                // Send to team 0 or another random team
                const dest = Math.random() < 0.7 ? 0 : Math.floor(Math.random() * numTeams);
                if (dest !== teamIdx) {
                  testTrade[teamIdx].playersOut.push({ ...p, destination: dest });
                  if (dest === 0) returnToTeam1 += p.salary;
                }
              }
              // Allow more players for star trades
              const maxPlayers = (isSuperstar || isStar) ? 4 : 2;
              if (testTrade[teamIdx].playersOut.length >= maxPlayers) break;
            }
          }
          
          // Check if we have enough players involved
          const totalPlayersOut = testTrade.reduce((sum, t) => sum + t.playersOut.length, 0);
          if (totalPlayersOut < numTeams) continue;
          
          // For star trades: add draft picks based on trade value comparison (50% chance per team)
          // Teams receiving more value than they send should compensate with picks
          if (isSuperstar || isStar) {
            // Calculate TV each team is sending out
            const teamTVsOut = testTrade.map(t => 
              t.playersOut.reduce((sum, p) => sum + (getTradeValue(p.player) || p.salary), 0)
            );
            
            // Team 0 (star's team) typically sends highest value
            const team0TV = teamTVsOut[0];
            
            for (let teamIdx = 1; teamIdx < numTeams; teamIdx++) {
              const teamTV = teamTVsOut[teamIdx];
              // If this team sends less value than team 0, they should send picks to team 0
              if (teamTV < team0TV && Math.random() < 0.50) {
                addPicksToTrade(testTrade, teamIdx, 0, isSuperstar);
              }
            }
          }
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        } else {
          // TWO-TEAM TRADE
          const partnerTeam = otherTeams[Math.floor(Math.random() * otherTeams.length)];
          
          // Target player goes to partner team
          const team1PlayersOut = [{ ...targetPlayer, destination: 1 }];
          let team1Outgoing = targetPlayer.salary;
          let team1TV = targetTV;
          
          // For stars: sometimes add teammates to the package (50% chance)
          if ((isSuperstar || isStar) && Math.random() < 0.50) {
            const teammates = tradeablePlayers
              .filter(p => p.team === targetTeam && p.player !== targetPlayer.player)
              .sort(() => Math.random() - 0.5);
            
            // Add 1-2 teammates
            const numTeammates = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < Math.min(numTeammates, teammates.length); i++) {
              team1PlayersOut.push({ ...teammates[i], destination: 1 });
              team1Outgoing += teammates[i].salary;
              team1TV += getTradeValue(teammates[i].player) || teammates[i].salary;
            }
          }
          
          // Partner team sends players back
          // For stars: sort by trade value to build better value packages
          let partnerPlayers = tradeablePlayers.filter(p => p.team === partnerTeam);
          
          if (isStar || isSuperstar) {
            // Sort by trade value descending - prioritize high-value players
            partnerPlayers = partnerPlayers.sort((a, b) => {
              const tvA = getTradeValue(a.player) || a.salary;
              const tvB = getTradeValue(b.player) || b.salary;
              return tvB - tvA;
            });
          } else {
            partnerPlayers = partnerPlayers.sort(() => Math.random() - 0.5);
          }
          
          let team2PlayersOut = [];
          let team2Outgoing = 0;
          let team2TV = 0;
          
          if (isSuperstar || isStar) {
            // For stars: build package targeting both salary AND trade value
            const targetTVThreshold = isSuperstar ? team1TV * 0.30 : team1TV * 0.40;
            
            for (const p of partnerPlayers) {
              const pTV = getTradeValue(p.player) || p.salary;
              team2PlayersOut.push({ ...p, destination: 0 });
              team2Outgoing += p.salary;
              team2TV += pTV;
              
              // Stop when we have enough trade value AND salary
              const hasSalary = team2Outgoing >= team1Outgoing * 0.75 - 5000000;
              const hasTV = team2TV >= targetTVThreshold;
              if (hasSalary && hasTV) break;
              if (team2PlayersOut.length >= 6) break; // Allow up to 6 players for stars
            }
          } else {
            // Non-stars: original salary-matching logic
            const singleMatch = partnerPlayers.find(p => {
              const wouldWork = p.salary >= team1Outgoing * 0.75 - 5000000 && 
                               p.salary <= team1Outgoing * 1.25 + 5000000;
              return wouldWork;
            });
            
            if (singleMatch && Math.random() < 0.4) {
              team2PlayersOut = [{ ...singleMatch, destination: 0 }];
              team2Outgoing = singleMatch.salary;
            } else {
              for (const p of partnerPlayers) {
                team2PlayersOut.push({ ...p, destination: 0 });
                team2Outgoing += p.salary;
                if (team2Outgoing >= team1Outgoing * 0.75 - 5000000) break;
                if (team2PlayersOut.length >= 3) break;
              }
            }
          }
          
          if (team2PlayersOut.length === 0) continue;
          
          // Build trade structure
          const testTrade = [
            { teamName: targetTeam, playersOut: team1PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
            { teamName: partnerTeam, playersOut: team2PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
          ];
          
          // For star trades: add draft picks based on trade value comparison (60% chance)
          // Team RECEIVING more trade value should SEND picks to balance
          if ((isSuperstar || isStar) && Math.random() < 0.60) {
            // Calculate trade value each team is sending out
            const team0TV = team1PlayersOut.reduce((sum, p) => sum + (getTradeValue(p.player) || p.salary), 0);
            const team1TV = team2PlayersOut.reduce((sum, p) => sum + (getTradeValue(p.player) || p.salary), 0);
            
            // Team receiving more value (sending less value) sends picks
            if (team0TV > team1TV) {
              // Team 0 sends more value, so team 1 (receiving Wemby) sends picks to team 0
              addPicksToTrade(testTrade, 1, 0, isSuperstar);
            } else if (team1TV > team0TV) {
              // Team 1 sends more value, so team 0 sends picks to team 1
              addPicksToTrade(testTrade, 0, 1, isSuperstar);
            }
          }
          
          // Redistribute and validate
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        }
      }
      
      return { error: `Could not generate a valid trade for ${targetPlayer.player}. Try again!` };
    }

    // Generate trade for multiple players from the same team
    function generateTradeForPlayers(playerNames) {
      // If single player, use original function
      if (playerNames.length === 1) {
        return generateTradeForPlayer(playerNames[0]);
      }
      
      const MAX_ATTEMPTS = 200;
      
      // Find all target players
      const targetPlayers = playerNames.map(name => 
        players.find(p => p.player.toLowerCase() === name.toLowerCase())
      ).filter(Boolean);
      
      if (targetPlayers.length !== playerNames.length) {
        return { error: `One or more players not found` };
      }
      
      // All players must be from the same team
      const targetTeam = targetPlayers[0].team;
      if (!targetPlayers.every(p => p.team === targetTeam)) {
        return { error: `All players must be from the same team` };
      }
      
      // Check if any player is not tradeable
      for (const p of targetPlayers) {
        if (p.contractStatus?.toUpperCase() === 'TWO-WAY' ||
            p.contractStatus?.toUpperCase().includes('10-DAY') ||
            p.tradeAvailable?.toLowerCase() === 'not available') {
          return { error: `${p.player} is not available for trade` };
        }
      }
      
      // Check 2nd Apron aggregation rule
      const teamInfo = getTeamInfo(targetTeam);
      if (teamInfo?.status?.toUpperCase().includes('2ND APRON') && targetPlayers.length > 1) {
        return { error: `${targetTeam} is a 2nd Apron team and cannot aggregate players in a trade` };
      }
      
      // Calculate total outgoing salary
      const totalOutgoing = targetPlayers.reduce((sum, p) => sum + p.salary, 0);
      
      // Get tradeable players from other teams
      const tradeablePlayers = players.filter(p => 
        p.team && 
        p.team !== targetTeam &&
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY') &&
        p.tradeAvailable?.toLowerCase() !== 'not available' &&
        p.salary >= 500000
      );
      
      const otherTeams = [...new Set(tradeablePlayers.map(p => p.team))];
      
      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        // 70% 2-team, 25% 3-team, 5% 4-team
        const rand = Math.random();
        const numTeams = rand < 0.7 ? 2 : rand < 0.95 ? 3 : 4;
        
        if (numTeams >= 3 && otherTeams.length >= numTeams - 1) {
          // MULTI-TEAM TRADE
          const shuffledOtherTeams = [...otherTeams].sort(() => Math.random() - 0.5);
          const involvedTeams = [targetTeam, ...shuffledOtherTeams.slice(0, numTeams - 1)];
          
          // All target players go to random other teams
          const team1PlayersOut = targetPlayers.map(p => {
            const dest = Math.floor(Math.random() * (numTeams - 1)) + 1;
            return { ...p, destination: dest };
          });
          
          const testTrade = involvedTeams.map((team, idx) => ({
            teamName: team,
            playersOut: idx === 0 ? team1PlayersOut : [],
            playersIn: [],
            tpeUsed: null,
            picksOut: [],
            rightsOut: [],
            cashOut: []
          }));
          
          // Other teams send players back
          let returnToTeam1 = 0;
          for (let teamIdx = 1; teamIdx < numTeams; teamIdx++) {
            const teamPlayers = tradeablePlayers
              .filter(p => p.team === involvedTeams[teamIdx])
              .sort(() => Math.random() - 0.5);
            
            for (const p of teamPlayers) {
              if (returnToTeam1 < totalOutgoing * 1.25 + 5000000) {
                const dest = Math.random() < 0.7 ? 0 : Math.floor(Math.random() * numTeams);
                if (dest !== teamIdx) {
                  testTrade[teamIdx].playersOut.push({ ...p, destination: dest });
                  if (dest === 0) returnToTeam1 += p.salary;
                }
              }
              if (testTrade[teamIdx].playersOut.length >= 3) break;
            }
          }
          
          // Add draft picks based on trade value comparison (40% chance per team)
          // Teams receiving more value than they send should compensate with picks
          const teamTVsOut = testTrade.map(t => 
            t.playersOut.reduce((sum, p) => sum + (getTradeValue(p.player) || p.salary), 0)
          );
          const team0TV = teamTVsOut[0];
          
          for (let teamIdx = 1; teamIdx < numTeams; teamIdx++) {
            const teamTV = teamTVsOut[teamIdx];
            // If this team sends less value than team 0, they should send picks
            if (teamTV < team0TV && Math.random() < 0.40) {
              addPicksToTrade(testTrade, teamIdx, 0, false);
            }
          }
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        } else {
          // TWO-TEAM TRADE
          const partnerTeam = otherTeams[Math.floor(Math.random() * otherTeams.length)];
          
          // Check 2nd Apron
          const partnerInfo = getTeamInfo(partnerTeam);
          const partnerIs2ndApron = partnerInfo?.status?.toUpperCase().includes('2ND APRON');
          
          // Target players go to partner team
          const team1PlayersOut = targetPlayers.map(p => ({ ...p, destination: 1 }));
          
          // Partner team sends players back
          const partnerPlayers = tradeablePlayers
            .filter(p => p.team === partnerTeam)
            .sort(() => Math.random() - 0.5);
          
          let team2PlayersOut = [];
          let team2Outgoing = 0;
          const maxPlayersFromPartner = partnerIs2ndApron ? 1 : 4;
          
          for (const p of partnerPlayers) {
            if (team2PlayersOut.length >= maxPlayersFromPartner) break;
            team2PlayersOut.push({ ...p, destination: 0 });
            team2Outgoing += p.salary;
            if (team2Outgoing >= totalOutgoing * 0.75 - 5000000) break;
          }
          
          if (team2PlayersOut.length === 0) continue;
          
          const testTrade = [
            { teamName: targetTeam, playersOut: team1PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
            { teamName: partnerTeam, playersOut: team2PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
          ];
          
          // Add draft picks based on trade value comparison (40% chance)
          if (Math.random() < 0.40) {
            const team0TV = team1PlayersOut.reduce((sum, p) => sum + (getTradeValue(p.player) || p.salary), 0);
            const team1TV = team2PlayersOut.reduce((sum, p) => sum + (getTradeValue(p.player) || p.salary), 0);
            
            // Team receiving more value sends picks
            if (team0TV > team1TV) {
              addPicksToTrade(testTrade, 1, 0, false); // Team 1 sends picks to team 0
            } else if (team1TV > team0TV) {
              addPicksToTrade(testTrade, 0, 1, false); // Team 0 sends picks to team 1
            }
          }
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        }
      }
      
      const playerNamesStr = targetPlayers.map(p => p.player).join(' & ');
      return { error: `Could not generate a valid trade for ${playerNamesStr}. Try again!` };
    }

    // Generate a random valid trade involving a specific team
    function generateTradeForTeam(teamName) {
      const MAX_ATTEMPTS = 200;
      
      // Verify team exists
      if (!teams.includes(teamName)) {
        return { error: `Team "${teamName}" not found` };
      }
      
      // Get tradeable players
      const tradeablePlayers = players.filter(p => 
        p.team && 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY') &&
        p.tradeAvailable?.toLowerCase() !== 'not available' &&
        p.salary >= 500000
      );
      
      // Get players from target team
      const teamPlayers = tradeablePlayers.filter(p => p.team === teamName);
      if (teamPlayers.length === 0) {
        return { error: `No tradeable players found for ${teamName}` };
      }
      
      // Get other teams
      const otherTeams = [...new Set(tradeablePlayers.map(p => p.team))].filter(t => t !== teamName);
      
      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        // Determine trade type: 60% 2-team, 35% 3-team, 5% 4-team
        const rand = Math.random();
        const numTeams = rand < 0.6 ? 2 : rand < 0.95 ? 3 : 4;
        
        // Pick 1 random player from target team
        const shuffledTeamPlayers = [...teamPlayers].sort(() => Math.random() - 0.5);
        const targetPlayer = shuffledTeamPlayers[0];
        
        if (numTeams >= 3 && otherTeams.length >= numTeams - 1) {
          // MULTI-TEAM TRADE (3 or 4 teams)
          const shuffledOtherTeams = [...otherTeams].sort(() => Math.random() - 0.5);
          const involvedTeams = [teamName, ...shuffledOtherTeams.slice(0, numTeams - 1)];
          
          // Target player goes to a random other team
          const targetDestination = Math.floor(Math.random() * (numTeams - 1)) + 1;
          const team1PlayersOut = [{ ...targetPlayer, destination: targetDestination }];
          const team1Outgoing = targetPlayer.salary;
          
          // Build trade structure
          const testTrade = involvedTeams.map((team, idx) => ({
            teamName: team,
            playersOut: idx === 0 ? team1PlayersOut : [],
            playersIn: [],
            tpeUsed: null,
            picksOut: [],
            rightsOut: [],
            cashOut: []
          }));
          
          // Other teams send players back to team 0 (target team)
          let returnToTeam1 = 0;
          
          for (let teamIdx = 1; teamIdx < numTeams; teamIdx++) {
            const otherTeamPlayers = tradeablePlayers
              .filter(p => p.team === involvedTeams[teamIdx])
              .sort(() => Math.random() - 0.5);
            
            for (const p of otherTeamPlayers) {
              if (returnToTeam1 < team1Outgoing * 1.25 + 5000000) {
                // Send to team 0 or another random team
                const dest = Math.random() < 0.7 ? 0 : Math.floor(Math.random() * numTeams);
                if (dest !== teamIdx) {
                  testTrade[teamIdx].playersOut.push({ ...p, destination: dest });
                  if (dest === 0) returnToTeam1 += p.salary;
                }
              }
              if (testTrade[teamIdx].playersOut.length >= 2) break;
            }
          }
          
          // Check if we have enough players involved
          const totalPlayersOut = testTrade.reduce((sum, t) => sum + t.playersOut.length, 0);
          if (totalPlayersOut < numTeams) continue;
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        } else {
          // TWO-TEAM TRADE
          const partnerTeam = otherTeams[Math.floor(Math.random() * otherTeams.length)];
          
          const team1PlayersOut = [{ ...targetPlayer, destination: 1 }];
          const team1Outgoing = targetPlayer.salary;
          
          const partnerPlayers = tradeablePlayers
            .filter(p => p.team === partnerTeam)
            .sort(() => Math.random() - 0.5);
          
          let team2PlayersOut = [];
          let team2Outgoing = 0;
          
          // First try to find a single player that works (1-for-1)
          const singleMatch = partnerPlayers.find(p => {
            const wouldWork = p.salary >= team1Outgoing * 0.75 - 5000000 && 
                             p.salary <= team1Outgoing * 1.25 + 5000000;
            return wouldWork;
          });
          
          if (singleMatch && Math.random() < 0.4) {
            // 40% chance to use single player match if found
            team2PlayersOut = [{ ...singleMatch, destination: 0 }];
            team2Outgoing = singleMatch.salary;
          } else {
            // Build package with minimum players needed
            for (const p of partnerPlayers) {
              team2PlayersOut.push({ ...p, destination: 0 });
              team2Outgoing += p.salary;
              
              // Stop once we have enough salary
              if (team2Outgoing >= team1Outgoing * 0.75 - 5000000) break;
              if (team2PlayersOut.length >= 3) break;
            }
          }
          
          if (team2PlayersOut.length === 0) continue;
          
          const testTrade = [
            { teamName: teamName, playersOut: team1PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
            { teamName: partnerTeam, playersOut: team2PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
          ];
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
            return testTrade;
          }
        }
      }
      
      return { error: `Could not generate a valid trade for ${teamName}. Try again!` };
    }
    
    // Selected player/team for autocomplete
    let selectedPlayer = null;
    let selectedTeam = null;
    
    // Unified trade generator variables
    let unifiedSelectedPlayers = []; // Players to trade
    let unifiedOriginTeam = null; // Auto-set from player, or manually set
    let unifiedDestTeam = null; // Destination team
    let excludedPlayers = []; // Players to exclude from trades
    
    // Render selected player chips for unified interface
    function renderUnifiedPlayerChips() {
      const container = document.getElementById('unifiedPlayerChips');
      const originInput = document.getElementById('unifiedOriginInput');
      
      if (unifiedSelectedPlayers.length === 0) {
        container.innerHTML = '';
        // Keep origin input enabled for manual team selection
        originInput.disabled = false;
        originInput.placeholder = 'Any team...';
        // Don't clear unifiedOriginTeam if manually set
        return;
      }
      
      // Auto-set origin team from first player and disable input
      const firstPlayerTeam = unifiedSelectedPlayers[0].team;
      unifiedOriginTeam = firstPlayerTeam;
      originInput.value = firstPlayerTeam;
      originInput.disabled = true;
      
      container.innerHTML = unifiedSelectedPlayers.map((p, idx) => `
        <span class="selected-player-chip">
          ${p.player}
          <span class="selected-player-chip-remove" data-idx="${idx}">√ó</span>
        </span>
      `).join('');
      
      container.querySelectorAll('.selected-player-chip-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const idx = parseInt(e.target.dataset.idx);
          unifiedSelectedPlayers.splice(idx, 1);
          renderUnifiedPlayerChips();
        });
      });
    }
    
    // Unified player autocomplete
    const unifiedPlayerInput = document.getElementById('unifiedPlayerInput');
    const unifiedPlayerDropdown = document.getElementById('unifiedPlayerDropdown');
    
    unifiedPlayerInput.addEventListener('input', () => {
      const searchTerm = unifiedPlayerInput.value.toLowerCase().trim();
      
      if (searchTerm.length < 2) {
        unifiedPlayerDropdown.classList.remove('show');
        return;
      }
      
      // Get the team of first selected player (if any) to filter same team only
      const selectedTeamFilter = unifiedSelectedPlayers.length > 0 ? unifiedSelectedPlayers[0].team : null;
      
      // Get tradeable players matching search
      const matches = players
        .filter(p => 
          p.team && 
          p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
          !p.contractStatus?.toUpperCase().includes('10-DAY') &&
          // If we already have players selected, only show same team
          (!selectedTeamFilter || p.team === selectedTeamFilter) &&
          // Don't show already selected players
          !unifiedSelectedPlayers.some(sp => sp.player === p.player) &&
          (p.player.toLowerCase().includes(searchTerm) ||
           p.player.toLowerCase().split(' ').some(part => part.startsWith(searchTerm)))
        )
        .slice(0, 10);
      
      if (matches.length === 0) {
        unifiedPlayerDropdown.classList.remove('show');
        return;
      }
      
      unifiedPlayerDropdown.innerHTML = matches.map(p => `
        <div class="autocomplete-item" data-player="${p.player}" data-team="${p.team}">
          <span>${p.player}</span>
          <span class="player-team">${p.team}</span>
        </div>
      `).join('');
      
      unifiedPlayerDropdown.classList.add('show');
      
      unifiedPlayerDropdown.querySelectorAll('.autocomplete-item').forEach(item => {
        item.addEventListener('click', () => {
          const playerName = item.dataset.player;
          const playerInfo = players.find(p => p.player === playerName);
          if (playerInfo && !unifiedSelectedPlayers.some(sp => sp.player === playerName)) {
            unifiedSelectedPlayers.push(playerInfo);
            renderUnifiedPlayerChips();
          }
          unifiedPlayerInput.value = '';
          unifiedPlayerDropdown.classList.remove('show');
        });
      });
    });
    
    // Unified origin team autocomplete
    const unifiedOriginInput = document.getElementById('unifiedOriginInput');
    const unifiedOriginDropdown = document.getElementById('unifiedOriginDropdown');
    
    unifiedOriginInput.addEventListener('input', () => {
      const searchTerm = unifiedOriginInput.value.toLowerCase().trim();
      
      // Only allow manual origin selection if no players selected
      if (unifiedSelectedPlayers.length > 0) {
        return;
      }
      
      unifiedOriginTeam = null;
      
      if (searchTerm.length < 2) {
        unifiedOriginDropdown.classList.remove('show');
        return;
      }
      
      // Exclude destination team from origins
      let matches = searchTeams(searchTerm);
      if (unifiedDestTeam) {
        matches = matches.filter(t => t !== unifiedDestTeam);
      }
      matches = matches.slice(0, 10);
      
      if (matches.length === 0) {
        unifiedOriginDropdown.classList.remove('show');
        return;
      }
      
      unifiedOriginDropdown.innerHTML = matches.map(t => `
        <div class="autocomplete-item" data-team="${t}">
          <span>${t}</span>
        </div>
      `).join('');
      
      unifiedOriginDropdown.classList.add('show');
      
      unifiedOriginDropdown.querySelectorAll('.autocomplete-item').forEach(item => {
        item.addEventListener('click', () => {
          unifiedOriginTeam = item.dataset.team;
          unifiedOriginInput.value = unifiedOriginTeam;
          unifiedOriginDropdown.classList.remove('show');
        });
      });
    });
    
    // Unified destination team autocomplete
    const unifiedDestInput = document.getElementById('unifiedDestInput');
    const unifiedDestDropdown = document.getElementById('unifiedDestDropdown');
    
    unifiedDestInput.addEventListener('input', () => {
      const searchTerm = unifiedDestInput.value.toLowerCase().trim();
      unifiedDestTeam = null;
      
      if (searchTerm.length < 2) {
        unifiedDestDropdown.classList.remove('show');
        return;
      }
      
      // Exclude origin team from destinations
      let matches = searchTeams(searchTerm);
      if (unifiedOriginTeam) {
        matches = matches.filter(t => t !== unifiedOriginTeam);
      }
      matches = matches.slice(0, 10);
      
      if (matches.length === 0) {
        unifiedDestDropdown.classList.remove('show');
        return;
      }
      
      unifiedDestDropdown.innerHTML = matches.map(t => `
        <div class="autocomplete-item" data-team="${t}">
          <span>${t}</span>
        </div>
      `).join('');
      
      unifiedDestDropdown.classList.add('show');
      
      unifiedDestDropdown.querySelectorAll('.autocomplete-item').forEach(item => {
        item.addEventListener('click', () => {
          unifiedDestTeam = item.dataset.team;
          unifiedDestInput.value = unifiedDestTeam;
          unifiedDestDropdown.classList.remove('show');
        });
      });
    });
    
    // Exclude players autocomplete
    const excludePlayersInput = document.getElementById('excludePlayersInput');
    const excludePlayersDropdown = document.getElementById('excludePlayersDropdown');
    const excludedChipsContainer = document.getElementById('excludedChips');
    
    // Render excluded player chips
    function renderExcludedChips() {
      excludedChipsContainer.innerHTML = excludedPlayers.map(name => `
        <span class="excluded-chip" data-player="${name}">
          ${name}
          <span class="excluded-chip-remove" data-player="${name}">√ó</span>
        </span>
      `).join('');
      
      excludedChipsContainer.querySelectorAll('.excluded-chip-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const playerName = e.target.dataset.player;
          excludedPlayers = excludedPlayers.filter(p => p !== playerName);
          renderExcludedChips();
        });
      });
    }
    
    excludePlayersInput.addEventListener('input', () => {
      const searchTerm = excludePlayersInput.value.toLowerCase().trim();
      
      if (searchTerm.length < 2) {
        excludePlayersDropdown.classList.remove('show');
        return;
      }
      
      // Filter to destination team if set, otherwise show all
      const teamFilter = unifiedDestTeam;
      
      const matches = players
        .filter(p => 
          p.team && 
          (!teamFilter || p.team === teamFilter) &&
          !excludedPlayers.includes(p.player) &&
          (p.player.toLowerCase().includes(searchTerm) ||
           p.player.toLowerCase().split(' ').some(part => part.startsWith(searchTerm)))
        )
        .slice(0, 10);
      
      if (matches.length === 0) {
        excludePlayersDropdown.classList.remove('show');
        return;
      }
      
      excludePlayersDropdown.innerHTML = matches.map(p => `
        <div class="autocomplete-item" data-player="${p.player}">
          <span>${p.player}</span>
          <span class="player-team">${p.team}</span>
        </div>
      `).join('');
      
      excludePlayersDropdown.classList.add('show');
      
      excludePlayersDropdown.querySelectorAll('.autocomplete-item').forEach(item => {
        item.addEventListener('click', () => {
          const playerName = item.dataset.player;
          if (!excludedPlayers.includes(playerName)) {
            excludedPlayers.push(playerName);
            renderExcludedChips();
          }
          excludePlayersInput.value = '';
          excludePlayersDropdown.classList.remove('show');
        });
      });
    });
    
    // Close all dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.autocomplete-container') && !e.target.closest('.excluded-chip')) {
        unifiedPlayerDropdown.classList.remove('show');
        unifiedOriginDropdown.classList.remove('show');
        unifiedDestDropdown.classList.remove('show');
        excludePlayersDropdown.classList.remove('show');
      }
    });
    
    // Unified generate trade function
    function generateUnifiedTrade() {
      const hasPlayers = unifiedSelectedPlayers.length > 0;
      const hasOrigin = unifiedOriginTeam !== null && unifiedOriginTeam !== '';
      const hasDest = unifiedDestTeam !== null && unifiedDestTeam !== '';
      
      let result = null;
      
      if (hasPlayers && hasDest) {
        // Player(s) to specific team
        const playerNames = unifiedSelectedPlayers.map(p => p.player);
        result = generateTradePlayersToTeam(playerNames, unifiedDestTeam, excludedPlayers);
      } else if (hasPlayers) {
        // Trade player(s) to any team
        const playerNames = unifiedSelectedPlayers.map(p => p.player);
        result = generateTradeForPlayers(playerNames);
      } else if (hasOrigin && hasDest) {
        // Trade between two specific teams
        result = generateTeamToTeamTrade(unifiedOriginTeam, unifiedDestTeam);
      } else if (hasOrigin) {
        // Trade involving origin team
        result = generateTradeForTeam(unifiedOriginTeam);
      } else if (hasDest) {
        // Trade involving destination team
        result = generateTradeForTeam(unifiedDestTeam);
      } else {
        // Pure random trade
        result = generateRandomTrade();
        if (!result) {
          result = generateSimpleFallbackTrade();
        }
      }
      
      return result;
    }
    
    // Generate trade between two specific teams
    function generateTeamToTeamTrade(originTeam, destTeam) {
      const MAX_ATTEMPTS = 200;
      
      // Verify teams exist
      if (!teams.includes(originTeam)) {
        return { error: `Team "${originTeam}" not found` };
      }
      if (!teams.includes(destTeam)) {
        return { error: `Team "${destTeam}" not found` };
      }
      
      // Get tradeable players
      const tradeablePlayers = players.filter(p => 
        p.team && 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY') &&
        p.tradeAvailable?.toLowerCase() !== 'not available' &&
        p.salary >= 500000
      );
      
      // Get players from both teams
      const originPlayers = tradeablePlayers.filter(p => p.team === originTeam);
      const destPlayers = tradeablePlayers.filter(p => p.team === destTeam);
      
      if (originPlayers.length === 0) {
        return { error: `No tradeable players found for ${originTeam}` };
      }
      if (destPlayers.length === 0) {
        return { error: `No tradeable players found for ${destTeam}` };
      }
      
      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        // Shuffle players
        const shuffledOrigin = [...originPlayers].sort(() => Math.random() - 0.5);
        const shuffledDest = [...destPlayers].sort(() => Math.random() - 0.5);
        
        // Pick 1-2 players from origin team
        const numOriginPlayers = Math.random() < 0.7 ? 1 : 2;
        const originPlayersOut = shuffledOrigin.slice(0, numOriginPlayers).map(p => ({ ...p, destination: 1 }));
        const originOutgoing = originPlayersOut.reduce((sum, p) => sum + p.salary, 0);
        
        // Find matching players from dest team
        const destPlayersOut = [];
        let destOutgoing = 0;
        
        for (const p of shuffledDest) {
          // Check if adding this player helps match salaries
          const newTotal = destOutgoing + p.salary;
          
          // Stop if we've matched enough
          if (destOutgoing >= originOutgoing * 0.8 && destOutgoing <= originOutgoing * 1.25 + 5000000) {
            break;
          }
          
          // Add player if it helps
          if (newTotal <= originOutgoing * 1.5 + 10000000) {
            destPlayersOut.push({ ...p, destination: 0 });
            destOutgoing = newTotal;
          }
          
          if (destPlayersOut.length >= 3) break;
        }
        
        if (destPlayersOut.length === 0) continue;
        
        // Build trade structure
        const testTrade = [
          { 
            teamName: originTeam, 
            playersOut: originPlayersOut, 
            playersIn: [], 
            tpeUsed: null, 
            picksOut: [], 
            rightsOut: [], 
            cashOut: [] 
          },
          { 
            teamName: destTeam, 
            playersOut: destPlayersOut, 
            playersIn: [], 
            tpeUsed: null, 
            picksOut: [], 
            rightsOut: [], 
            cashOut: [] 
          }
        ];
        
        tradeTeams = testTrade;
        redistributePlayers(true);
        
        const validation = validateTrade();
        if ((validation.valid || validation.type.startsWith('pending')) && isTradeValueBalanced(testTrade)) {
          return testTrade;
        }
      }
      
      return { error: `Could not generate a valid trade between ${originTeam} and ${destTeam}. Try different teams!` };
    }
    
    // Generate button handler
    const generateTradeBtn = document.getElementById('generateTradeBtn');
    
    generateTradeBtn.addEventListener('click', () => {
      const result = generateUnifiedTrade();
      
      if (result && result.error) {
        tradeStatus.style.display = 'flex';
        tradeStatus.className = 'trade-status invalid';
        document.getElementById('tradeStatusIcon').textContent = '‚úï';
        document.getElementById('tradeStatusTitle').textContent = 'Cannot generate trade';
        document.getElementById('tradeStatusMessage').textContent = result.error;
      } else if (result) {
        tradeTeams = result;
        redistributePlayers(true);
        render();
      }
    });
    
    // Enter key triggers generate
    unifiedPlayerInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        unifiedPlayerDropdown.classList.remove('show');
        generateTradeBtn.click();
      }
    });
    
    unifiedDestInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        unifiedDestDropdown.classList.remove('show');
        generateTradeBtn.click();
      }
    });
    
    // Track previously generated trades to avoid repeats on multiple clicks
    let previousPlayerToTeamTrades = new Set();
    
    // Generate trade for specific player to specific team
    function generateTradePlayerToTeam(playerName, destTeamName, excludedPlayerNames = []) {
      // Convert excluded names to lowercase for comparison
      const excludedSet = new Set(excludedPlayerNames.map(n => n.toLowerCase()));
      
      // Find the target player
      const targetPlayer = players.find(p => 
        p.player.toLowerCase() === playerName.toLowerCase()
      );
      
      if (!targetPlayer) {
        return { error: `Player "${playerName}" not found` };
      }
      
      // Check if player is tradeable
      if (targetPlayer.contractStatus?.toUpperCase() === 'TWO-WAY' ||
          targetPlayer.contractStatus?.toUpperCase().includes('10-DAY') ||
          targetPlayer.tradeAvailable?.toLowerCase() === 'not available') {
        return { error: `${targetPlayer.player} is not available for trade` };
      }
      
      const sourceTeam = targetPlayer.team;
      
      // Check destination team exists and is different
      if (!teams.includes(destTeamName)) {
        return { error: `Team "${destTeamName}" not found` };
      }
      
      if (sourceTeam === destTeamName) {
        return { error: `${targetPlayer.player} is already on ${destTeamName}` };
      }
      
      // Helper to check if player is excluded
      function isExcluded(playerObj) {
        return excludedSet.has(playerObj.player.toLowerCase());
      }
      
      // Get tradeable players from a team (excluding excluded players)
      function getTradeablePlayers(teamName) {
        return players.filter(p => 
          p.team === teamName &&
          p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
          !p.contractStatus?.toUpperCase().includes('10-DAY') &&
          p.tradeAvailable?.toLowerCase() !== 'not available' &&
          p.salary > 0 &&
          !isExcluded(p)
        );
      }
      
      // Shuffle array helper for variety
      function shuffle(arr) {
        const shuffled = [...arr];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }
      
      function getTradeKey(trade) {
        return trade.map(t => 
          `${t.teamName}:${t.playersOut.map(p => p.player).sort().join(',')}`
        ).sort().join('|');
      }
      
      // Get all other teams for potential 3rd/4th team - shuffled for variety
      const otherTeams = shuffle(teams.filter(t => t !== sourceTeam && t !== destTeamName));
      
      // Get destination team players - shuffled for variety on repeated clicks
      const destTeamPlayers = shuffle(getTradeablePlayers(destTeamName));
      
      if (destTeamPlayers.length === 0) {
        return { error: `No tradeable players on ${destTeamName} (after exclusions)` };
      }
      
      const targetSalary = targetPlayer.salary;
      
      // Collect valid trades to find one we haven't shown yet
      const validTrades = [];
      const MAX_VALID_TRADES = 20; // Collect up to 20 valid trades then pick randomly
      
      // Generate all possible combinations
      function* generateCombinations(arr, minSize, maxSize) {
        for (let size = minSize; size <= Math.min(maxSize, arr.length); size++) {
          yield* combinations(arr, size);
        }
      }
      
      function* combinations(arr, size) {
        if (size === 1) {
          for (const item of arr) yield [item];
        } else {
          for (let i = 0; i <= arr.length - size; i++) {
            for (const combo of combinations(arr.slice(i + 1), size - 1)) {
              yield [arr[i], ...combo];
            }
          }
        }
      }
      
      // Try 2-team trades first (most common)
      for (const combo of generateCombinations(destTeamPlayers, 1, 5)) {
        const comboSalary = combo.reduce((sum, p) => sum + p.salary, 0);
        
        // Quick salary check - skip if obviously won't work
        if (comboSalary < targetSalary * 0.5 || comboSalary > targetSalary * 2) continue;
        
        const team2PlayersOut = combo.map(p => ({ ...p, destination: 0 }));
        
        const testTrade = [
          { teamName: sourceTeam, playersOut: [{ ...targetPlayer, destination: 1 }], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
          { teamName: destTeamName, playersOut: team2PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
        ];
        
        const tradeKey = getTradeKey(testTrade);
        
        // Skip if we've already shown this trade
        if (previousPlayerToTeamTrades.has(tradeKey)) continue;
        
        tradeTeams = testTrade;
        redistributePlayers(true);
        
        const validation = validateTrade();
        if (validation.valid || validation.type?.startsWith('pending')) {
          validTrades.push({ trade: JSON.parse(JSON.stringify(testTrade)), key: tradeKey, teams: 2 });
          if (validTrades.length >= MAX_VALID_TRADES) break;
        }
      }
      
      // Also collect 3-team trades
      const valid3TeamTrades = [];
      let attempts3Team = 0;
      for (const thirdTeam of otherTeams) {
        if (attempts3Team > 100 || valid3TeamTrades.length >= 10) break;
        
        const thirdTeamPlayers = shuffle(getTradeablePlayers(thirdTeam));
        if (thirdTeamPlayers.length === 0) continue;
        
        // Try different combinations where:
        // - Target player goes to destTeam
        // - DestTeam sends players to thirdTeam
        // - ThirdTeam sends players to sourceTeam
        for (const destCombo of generateCombinations(destTeamPlayers.slice(0, 6), 1, 3)) {
          if (attempts3Team > 100 || valid3TeamTrades.length >= 10) break;
          
          for (const thirdCombo of generateCombinations(thirdTeamPlayers.slice(0, 6), 1, 4)) {
            if (attempts3Team > 100 || valid3TeamTrades.length >= 10) break;
            attempts3Team++;
            
            const thirdComboSalary = thirdCombo.reduce((sum, p) => sum + p.salary, 0);
            if (thirdComboSalary < targetSalary * 0.5 || thirdComboSalary > targetSalary * 2) continue;
            
            const testTrade = [
              { teamName: sourceTeam, playersOut: [{ ...targetPlayer, destination: 1 }], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
              { teamName: destTeamName, playersOut: destCombo.map(p => ({ ...p, destination: 2 })), playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
              { teamName: thirdTeam, playersOut: thirdCombo.map(p => ({ ...p, destination: 0 })), playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
            ];
            
            const tradeKey = getTradeKey(testTrade);
            if (previousPlayerToTeamTrades.has(tradeKey)) continue;
            
            tradeTeams = testTrade;
            redistributePlayers(true);
            
            const validation = validateTrade();
            if (validation.valid || validation.type?.startsWith('pending')) {
              valid3TeamTrades.push({ trade: JSON.parse(JSON.stringify(testTrade)), key: tradeKey, teams: 3 });
            }
          }
        }
      }
      
      // Also collect 4-team trades
      const valid4TeamTrades = [];
      let attempts4Team = 0;
      for (let i = 0; i < otherTeams.length && attempts4Team < 50; i++) {
        for (let j = i + 1; j < otherTeams.length && attempts4Team < 50; j++) {
          if (valid4TeamTrades.length >= 5) break;
          
          const thirdTeam = otherTeams[i];
          const fourthTeam = otherTeams[j];
          
          const thirdTeamPlayers = shuffle(getTradeablePlayers(thirdTeam));
          const fourthTeamPlayers = shuffle(getTradeablePlayers(fourthTeam));
          
          if (thirdTeamPlayers.length === 0 || fourthTeamPlayers.length === 0) continue;
          
          // Try a few combinations
          for (const destCombo of generateCombinations(destTeamPlayers.slice(0, 4), 1, 2)) {
            if (attempts4Team > 50 || valid4TeamTrades.length >= 5) break;
            
            for (const thirdCombo of generateCombinations(thirdTeamPlayers.slice(0, 4), 1, 2)) {
              if (attempts4Team > 50 || valid4TeamTrades.length >= 5) break;
              
              for (const fourthCombo of generateCombinations(fourthTeamPlayers.slice(0, 4), 1, 3)) {
                if (attempts4Team > 50 || valid4TeamTrades.length >= 5) break;
                attempts4Team++;
                
                const fourthComboSalary = fourthCombo.reduce((sum, p) => sum + p.salary, 0);
                if (fourthComboSalary < targetSalary * 0.5 || fourthComboSalary > targetSalary * 2) continue;
                
                const testTrade = [
                  { teamName: sourceTeam, playersOut: [{ ...targetPlayer, destination: 1 }], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
                  { teamName: destTeamName, playersOut: destCombo.map(p => ({ ...p, destination: 2 })), playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
                  { teamName: thirdTeam, playersOut: thirdCombo.map(p => ({ ...p, destination: 3 })), playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
                  { teamName: fourthTeam, playersOut: fourthCombo.map(p => ({ ...p, destination: 0 })), playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
                ];
                
                const tradeKey = getTradeKey(testTrade);
                if (previousPlayerToTeamTrades.has(tradeKey)) continue;
                
                tradeTeams = testTrade;
                redistributePlayers(true);
                
                const validation = validateTrade();
                if (validation.valid || validation.type?.startsWith('pending')) {
                  valid4TeamTrades.push({ trade: JSON.parse(JSON.stringify(testTrade)), key: tradeKey, teams: 4 });
                }
              }
            }
          }
        }
      }
      
      // Now pick from all valid trades with weighted probability: 65% 2-team, 30% 3-team, 5% 4-team
      const allValidTrades = [];
      
      // Add trades with weights
      if (validTrades.length > 0) {
        // Pick one random 2-team trade and give it 65% weight
        const picked2 = validTrades[Math.floor(Math.random() * validTrades.length)];
        for (let i = 0; i < 65; i++) allValidTrades.push(picked2);
      }
      if (valid3TeamTrades.length > 0) {
        // Pick one random 3-team trade and give it 30% weight
        const picked3 = valid3TeamTrades[Math.floor(Math.random() * valid3TeamTrades.length)];
        for (let i = 0; i < 30; i++) allValidTrades.push(picked3);
      }
      if (valid4TeamTrades.length > 0) {
        // Pick one random 4-team trade and give it 5% weight
        const picked4 = valid4TeamTrades[Math.floor(Math.random() * valid4TeamTrades.length)];
        for (let i = 0; i < 5; i++) allValidTrades.push(picked4);
      }
      
      if (allValidTrades.length > 0) {
        const picked = allValidTrades[Math.floor(Math.random() * allValidTrades.length)];
        previousPlayerToTeamTrades.add(picked.key);
        return picked.trade;
      }
      
      // If no new trades found, clear history and try again (allows cycling through)
      if (previousPlayerToTeamTrades.size > 0) {
        previousPlayerToTeamTrades.clear();
        return generateTradePlayerToTeam(playerName, destTeamName, excludedPlayerNames);
      }
      
      return { error: `Could not find a valid trade to send ${targetPlayer.player} to ${destTeamName}. Try removing some exclusions or a different destination!` };
    }
    
    // Generate trade for multiple players to a specific team
    function generateTradePlayersToTeam(playerNames, destTeamName, excludedPlayerNames = []) {
      // If single player, use original function
      if (playerNames.length === 1) {
        return generateTradePlayerToTeam(playerNames[0], destTeamName, excludedPlayerNames);
      }
      
      const excludedSet = new Set(excludedPlayerNames.map(n => n.toLowerCase()));
      
      // Find all target players
      const targetPlayers = playerNames.map(name => 
        players.find(p => p.player.toLowerCase() === name.toLowerCase())
      ).filter(Boolean);
      
      if (targetPlayers.length !== playerNames.length) {
        return { error: `One or more players not found` };
      }
      
      // All players must be from the same team
      const sourceTeam = targetPlayers[0].team;
      if (!targetPlayers.every(p => p.team === sourceTeam)) {
        return { error: `All players must be from the same team` };
      }
      
      // Check if any player is not tradeable
      for (const p of targetPlayers) {
        if (p.contractStatus?.toUpperCase() === 'TWO-WAY' ||
            p.contractStatus?.toUpperCase().includes('10-DAY') ||
            p.tradeAvailable?.toLowerCase() === 'not available') {
          return { error: `${p.player} is not available for trade` };
        }
      }
      
      // Verify destination team
      if (!teams.includes(destTeamName)) {
        return { error: `Team "${destTeamName}" not found` };
      }
      
      if (sourceTeam === destTeamName) {
        return { error: `Players are already on ${destTeamName}` };
      }
      
      // Check 2nd Apron aggregation rule
      const teamInfo = getTeamInfo(sourceTeam);
      if (teamInfo?.status?.toUpperCase().includes('2ND APRON') && targetPlayers.length > 1) {
        return { error: `${sourceTeam} is a 2nd Apron team and cannot aggregate players` };
      }
      
      const totalOutgoing = targetPlayers.reduce((sum, p) => sum + p.salary, 0);
      
      function isExcluded(playerObj) {
        return excludedSet.has(playerObj.player.toLowerCase());
      }
      
      function getTradeablePlayers(teamName) {
        return players.filter(p => 
          p.team === teamName &&
          p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
          !p.contractStatus?.toUpperCase().includes('10-DAY') &&
          p.tradeAvailable?.toLowerCase() !== 'not available' &&
          p.salary > 0 &&
          !isExcluded(p)
        );
      }
      
      function shuffle(arr) {
        const shuffled = [...arr];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }
      
      const destTeamPlayers = shuffle(getTradeablePlayers(destTeamName));
      const otherTeams = shuffle(teams.filter(t => t !== sourceTeam && t !== destTeamName));
      
      if (destTeamPlayers.length === 0) {
        return { error: `No tradeable players on ${destTeamName} (after exclusions)` };
      }
      
      const MAX_ATTEMPTS = 200;
      
      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        // 70% 2-team, 25% 3-team, 5% 4-team
        const rand = Math.random();
        const numTeams = rand < 0.7 ? 2 : rand < 0.95 ? 3 : 4;
        
        if (numTeams === 2) {
          // 2-team trade: source sends players to dest, dest sends players back
          const team1PlayersOut = targetPlayers.map(p => ({ ...p, destination: 1 }));
          
          let team2PlayersOut = [];
          let team2Outgoing = 0;
          
          const shuffledDest = shuffle(destTeamPlayers);
          for (const p of shuffledDest) {
            team2PlayersOut.push({ ...p, destination: 0 });
            team2Outgoing += p.salary;
            if (team2Outgoing >= totalOutgoing * 0.75 - 5000000) break;
            if (team2PlayersOut.length >= 5) break;
          }
          
          if (team2PlayersOut.length === 0) continue;
          
          const testTrade = [
            { teamName: sourceTeam, playersOut: team1PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
            { teamName: destTeamName, playersOut: team2PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
          ];
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if (validation.valid || validation.type?.startsWith('pending')) {
            return testTrade;
          }
        } else if (numTeams >= 3 && otherTeams.length >= 1) {
          // 3 or 4-team trade
          const thirdTeam = otherTeams[Math.floor(Math.random() * otherTeams.length)];
          const thirdTeamPlayers = shuffle(getTradeablePlayers(thirdTeam));
          
          if (thirdTeamPlayers.length === 0) continue;
          
          // Target players go to dest, dest sends to third, third sends to source
          const team1PlayersOut = targetPlayers.map(p => ({ ...p, destination: 1 }));
          
          let team2PlayersOut = [];
          for (const p of shuffle(destTeamPlayers).slice(0, 3)) {
            team2PlayersOut.push({ ...p, destination: 2 });
          }
          
          let team3PlayersOut = [];
          let team3Outgoing = 0;
          for (const p of thirdTeamPlayers) {
            team3PlayersOut.push({ ...p, destination: 0 });
            team3Outgoing += p.salary;
            if (team3Outgoing >= totalOutgoing * 0.75 - 5000000) break;
            if (team3PlayersOut.length >= 4) break;
          }
          
          if (team2PlayersOut.length === 0 || team3PlayersOut.length === 0) continue;
          
          const testTrade = [
            { teamName: sourceTeam, playersOut: team1PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
            { teamName: destTeamName, playersOut: team2PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
            { teamName: thirdTeam, playersOut: team3PlayersOut, playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
          ];
          
          tradeTeams = testTrade;
          redistributePlayers(true);
          
          const validation = validateTrade();
          if (validation.valid || validation.type?.startsWith('pending')) {
            return testTrade;
          }
        }
      }
      
      const playerNamesStr = targetPlayers.map(p => p.player).join(' & ');
      return { error: `Could not find a valid trade to send ${playerNamesStr} to ${destTeamName}. Try removing some exclusions!` };
    }
    
    // Loop feature - auto-generate trades every 8 seconds
    let loopInterval = null;
    const loopTradeBtn = document.getElementById('loopTradeBtn');
    const shareLoopBtn = document.getElementById('shareLoopBtn');
    
    // Generate loop URL based on current settings
    function generateLoopUrl() {
      const params = new URLSearchParams();
      
      // Add player(s)
      if (unifiedSelectedPlayers.length > 0) {
        const playerSlugs = unifiedSelectedPlayers.map(p => 
          p.player.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '')
        );
        params.set('player', playerSlugs.join(','));
      }
      
      // Add from team (only if no player selected, since player auto-sets it)
      if (unifiedOriginTeam && unifiedSelectedPlayers.length === 0) {
        const teamSlug = unifiedOriginTeam.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
        params.set('from', teamSlug);
      }
      
      // Add to team
      if (unifiedDestTeam) {
        const teamSlug = unifiedDestTeam.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
        params.set('to', teamSlug);
      }
      
      // Add excluded players (handle both string names and player objects)
      if (excludedPlayers.length > 0) {
        const excludeSlugs = excludedPlayers.map(p => {
          const playerName = typeof p === 'string' ? p : p.player;
          return playerName.replace(/[^a-zA-Z0-9]+/g, '-').replace(/^-|-$/g, '');
        });
        params.set('exclude', excludeSlugs.join(','));
      }
      
      // Add loop flag
      params.set('loop', '1');
      
      return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
    }
    
    // Share loop button click handler
    shareLoopBtn.addEventListener('click', async () => {
      const url = generateLoopUrl();
      
      try {
        await navigator.clipboard.writeText(url);
        shareLoopBtn.textContent = '‚úì Copied!';
        shareLoopBtn.classList.add('copied');
        setTimeout(() => {
          shareLoopBtn.textContent = 'üîó Share Loop';
          shareLoopBtn.classList.remove('copied');
        }, 2000);
      } catch (err) {
        // Fallback for older browsers
        prompt('Copy this link:', url);
      }
    });
    
    function stopLoop() {
      if (loopInterval) {
        clearTimeout(loopInterval); // Clear timeout (for first 4-second wait)
        clearInterval(loopInterval); // Clear interval (for 8-second repeats)
        loopInterval = null;
      }
      loopTradeBtn.classList.remove('active');
      loopTradeBtn.textContent = '‚ñ∂ Trade Loop';
      shareLoopBtn.style.display = 'none';
    }
    
    function startLoop() {
      stopLoop(); // Clear any existing loop
      loopTradeBtn.classList.add('active');
      loopTradeBtn.textContent = '‚èπ Stop';
      shareLoopBtn.style.display = 'inline-flex';
      
      // Execute immediately
      executeLoopTrade();
      
      // Then after 4 seconds for the second trade, then 8 seconds thereafter
      loopInterval = setTimeout(() => {
        executeLoopTrade();
        // Now switch to 8-second intervals
        loopInterval = setInterval(executeLoopTrade, 6500);
      }, 4000);
    }
    
    function executeLoopTrade() {
      const result = generateUnifiedTrade();
      
      if (result && !result.error) {
        tradeTeams = result;
        redistributePlayers(true);
        render();
      }
    }
    
    loopTradeBtn.addEventListener('click', () => {
      if (loopInterval) {
        stopLoop();
      } else {
        startLoop();
      }
    });
    
    // Stop loop when reset is clicked
    resetBtn.addEventListener('click', () => {
      stopLoop();
      // Clear unified inputs
      unifiedSelectedPlayers = [];
      unifiedOriginTeam = null;
      unifiedDestTeam = null;
      excludedPlayers = [];
      document.getElementById('unifiedPlayerInput').value = '';
      document.getElementById('unifiedOriginInput').value = '';
      document.getElementById('unifiedOriginInput').disabled = false;
      document.getElementById('unifiedDestInput').value = '';
      renderUnifiedPlayerChips();
      renderExcludedChips();
    }, { capture: true });
    
    // Simple fallback trade generator - finds two players with similar salaries
    function generateSimpleFallbackTrade() {
      const tradeablePlayers = players.filter(p => 
        p.team && 
        p.contractStatus?.toUpperCase() !== 'TWO-WAY' &&
        !p.contractStatus?.toUpperCase().includes('10-DAY') &&
        p.tradeAvailable?.toLowerCase() !== 'not available' &&
        p.salary >= 1000000
      );
      
      // Shuffle players
      const shuffled = [...tradeablePlayers].sort(() => Math.random() - 0.5);
      
      for (const player1 of shuffled) {
        // Find a player from a different team with salary within 25% + $250K
        for (const player2 of shuffled) {
          if (player1.team === player2.team) continue;
          if (player1.player === player2.player) continue;
          
          const salaryDiff = Math.abs(player1.salary - player2.salary);
          const maxDiff = Math.max(player1.salary, player2.salary) * 0.25 + 250000;
          
          if (salaryDiff <= maxDiff) {
            // Found a match!
            const testTrade = [
              { 
                teamName: player1.team, 
                playersOut: [{ ...player1, destination: 1 }], 
                playersIn: [player2],
                tpeUsed: null,
                picksOut: [],
                rightsOut: [],
                cashOut: []
              },
              { 
                teamName: player2.team, 
                playersOut: [{ ...player2, destination: 0 }], 
                playersIn: [player1],
                tpeUsed: null,
                picksOut: [],
                rightsOut: [],
                cashOut: []
              }
            ];
            
            // Quick validation (including 2nd Apron check and trade value balance)
            const team1Valid = validateTeamTrade(testTrade[0]);
            const team2Valid = validateTeamTrade(testTrade[1]);
            const team1Apron = check2ndApronRestrictions(testTrade[0]);
            const team2Apron = check2ndApronRestrictions(testTrade[1]);
            
            if (team1Valid.valid && team2Valid.valid && team1Apron.valid && team2Apron.valid && isTradeValueBalanced(testTrade)) {
              return testTrade;
            }
          }
        }
      }
      
      return null;
    }

    // Reset trade
    resetBtn.addEventListener('click', () => {
      tradeTeams = [
        { teamName: '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
        { teamName: '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
      ];
      render();
    });

    // Generate Trade Image
    const generateImageBtn = document.getElementById('generateImageBtn');
    const imageModal = document.getElementById('imageModal');
    const closeImageModal = document.getElementById('closeImageModal');
    const generatedImage = document.getElementById('generatedImage');
    const downloadImageBtn = document.getElementById('downloadImageBtn');
    const copyImageBtn = document.getElementById('copyImageBtn');
    const tradeCanvas = document.getElementById('tradeCanvas');
    let currentImageFormat = 'twitter'; // 'twitter' (16:9), 'instagram' (1:1), 'stories' (9:16)

    // Format button handlers
    document.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentImageFormat = btn.dataset.format;
        generatedImage.style.opacity = '0.5';
        await generateTradeImage();
        generatedImage.style.opacity = '1';
      });
    });

    generateImageBtn.addEventListener('click', async () => {
      // Check if there's a valid trade
      const activeTeams = tradeTeams.filter(t => t.teamName && (t.playersOut.length > 0 || t.playersIn.length > 0));
      if (activeTeams.length < 2) {
        alert('Please create a trade with at least 2 teams first');
        return;
      }

      // Show loading state on button
      const originalText = generateImageBtn.textContent;
      generateImageBtn.textContent = '‚è≥ Generating...';
      generateImageBtn.disabled = true;
      
      await generateTradeImage();
      
      // Restore button and show modal
      generateImageBtn.textContent = originalText;
      generateImageBtn.disabled = false;
      imageModal.style.display = 'flex';
    });

    closeImageModal.addEventListener('click', () => {
      imageModal.style.display = 'none';
    });

    imageModal.addEventListener('click', (e) => {
      if (e.target === imageModal) {
        imageModal.style.display = 'none';
      }
    });

    downloadImageBtn.addEventListener('click', () => {
      try {
        const link = document.createElement('a');
        link.download = 'nba-trade.png';
        link.href = tradeCanvas.toDataURL('image/png');
        link.click();
      } catch (e) {
        alert('Unable to download image due to security restrictions. Try using a screenshot instead.');
      }
    });

    copyImageBtn.addEventListener('click', async () => {
      try {
        const blob = await new Promise(resolve => tradeCanvas.toBlob(resolve, 'image/png'));
        await navigator.clipboard.write([
          new ClipboardItem({ 'image/png': blob })
        ]);
        copyImageBtn.textContent = '‚úì Copied!';
        setTimeout(() => {
          copyImageBtn.textContent = 'üìã Copy to Clipboard';
        }, 2000);
      } catch (err) {
        alert('Failed to copy image. Try downloading instead.');
      }
    });

    async function generateTradeImage() {
      const ctx = tradeCanvas.getContext('2d');
      const activeTeams = tradeTeams.filter(t => t.teamName && (t.playersOut.length > 0 || t.playersIn.length > 0 || (t.picksOut && t.picksOut.length > 0) || (t.rightsOut && t.rightsOut.length > 0)));
      
      // Collect all images to preload
      const imagesToLoad = [];
      const loadedImages = new Map();
      
      // Helper to proxy external images through our API (bypasses CORS)
      const proxyUrl = (url) => {
        if (!url) return null;
        return `https://hoopshype-rumors-api.thejorgesierra.workers.dev/api/image-proxy?url=${encodeURIComponent(url)}`;
      };
      
      // Helper to load an image (uses proxy to bypass CORS)
      const loadImage = (url) => {
        if (!url) return Promise.resolve(null);
        if (loadedImages.has(url)) return Promise.resolve(loadedImages.get(url));
        
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            loadedImages.set(url, img); // Store by original URL
            resolve(img);
          };
          img.onerror = () => resolve(null);
          img.src = proxyUrl(url); // Load via proxy
        });
      };
      
      // Collect team logos and player headshots
      for (const team of activeTeams) {
        const teamInfo = getTeamInfo(team.teamName);
        if (teamInfo?.logo) imagesToLoad.push(loadImage(teamInfo.logo));
        
        for (const player of team.playersOut) {
          if (player.headshot) imagesToLoad.push(loadImage(player.headshot));
        }
        for (const player of team.playersIn) {
          if (player.headshot) imagesToLoad.push(loadImage(player.headshot));
        }
      }
      
      // Wait for all images to load (with timeout)
      await Promise.race([
        Promise.all(imagesToLoad),
        new Promise(resolve => setTimeout(resolve, 3000))
      ]);
      
      // Format-specific dimensions
      const formatConfigs = {
        twitter: { ratio: 16/9, teamWidth: 360, maxTeams: 4 },
        instagram: { ratio: 1, teamWidth: 320, maxTeams: 3 },
        stories: { ratio: 9/16, teamWidth: 300, maxTeams: 2 }
      };
      
      const config = formatConfigs[currentImageFormat] || formatConfigs.twitter;
      const teamWidth = config.teamWidth;
      const teamGap = 20;
      const padding = 32;
      const headerHeight = 100;
      const teamHeaderHeight = 80;
      const playerRowHeight = 56;
      const assetRowHeight = 40;
      const sectionLabelHeight = 28;
      const summaryHeight = 90;
      const footerHeight = 40;
      
      // Helper to get incoming assets for a team
      function getIncomingAssets(teamIndex) {
        const incomingPicks = [];
        const incomingRights = [];
        let incomingCash = 0;
        
        tradeTeams.forEach((otherTeam, otherIndex) => {
          if (otherIndex !== teamIndex && otherTeam.teamName) {
            if (otherTeam.picksOut) {
              otherTeam.picksOut.forEach(pick => {
                const dest = pick.destination !== undefined ? pick.destination : (tradeTeams.length === 2 ? teamIndex : undefined);
                if (dest === teamIndex) {
                  incomingPicks.push({...pick, fromTeam: otherTeam.teamName});
                }
              });
            }
            if (otherTeam.rightsOut) {
              otherTeam.rightsOut.forEach(rights => {
                const dest = rights.destination !== undefined ? rights.destination : (tradeTeams.length === 2 ? teamIndex : undefined);
                if (dest === teamIndex) {
                  incomingRights.push({...rights, fromTeam: otherTeam.teamName});
                }
              });
            }
            if (otherTeam.cashOut && otherTeam.cashOut.length > 0) {
              otherTeam.cashOut.forEach(cash => {
                const dest = cash.destination !== undefined ? cash.destination : (tradeTeams.length === 2 ? teamIndex : undefined);
                if (dest === teamIndex) {
                  incomingCash++;
                }
              });
            }
          }
        });
        return { incomingPicks, incomingRights, incomingCash };
      }
      
      // Helper to get player badges
      function getPlayerBadges(player) {
        const badges = [];
        if (player.contractStatus?.toUpperCase() === 'TWO-WAY') badges.push({ text: 'TW', bg: '#dbeafe', color: '#1d4ed8' });
        if (player.is10Day) badges.push({ text: '10D', bg: '#fee2e2', color: '#dc2626' });
        if (player.noTradeClause) badges.push({ text: 'NTC', bg: '#fef3c7', color: '#b45309' });
        if (player.notAggregated) badges.push({ text: 'NA', bg: '#fce7f3', color: '#be185d' });
        if (player.poisonPill > 0) badges.push({ text: 'PP', bg: '#ede9fe', color: '#7c3aed' });
        if (player.tradeKicker > 0) badges.push({ text: 'TK', bg: '#d1fae5', color: '#059669' });
        if (player.isMinSalaryException) badges.push({ text: 'MSE', bg: '#e0f2fe', color: '#0284c7' });
        return badges;
      }
      
      // Calculate content height for each team
      const displayTeams = activeTeams.slice(0, config.maxTeams);
      const teamHeights = displayTeams.map((team, idx) => {
        const teamIndex = tradeTeams.indexOf(team);
        const { incomingPicks, incomingRights, incomingCash } = getIncomingAssets(teamIndex);
        
        let height = teamHeaderHeight + 16;
        
        // Calculate if TPE is actually used (deficit exists)
        const outgoingSalary = team.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
        const incomingSalary = team.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
        const deficit = incomingSalary - outgoingSalary;
        const usesTPE = (team.tpeUsed && deficit > 0) ? 1 : 0;
        
        const sendsOutCount = team.playersOut.length + 
          (team.picksOut ? team.picksOut.length : 0) + 
          (team.rightsOut ? team.rightsOut.length : 0) +
          (team.cashOut ? team.cashOut.length : 0) +
          usesTPE;
        if (sendsOutCount > 0) {
          height += sectionLabelHeight;
          height += team.playersOut.length * playerRowHeight;
          height += (team.picksOut ? team.picksOut.length : 0) * assetRowHeight;
          height += (team.rightsOut ? team.rightsOut.length : 0) * assetRowHeight;
          height += (team.cashOut ? team.cashOut.length : 0) * assetRowHeight;
          height += usesTPE * assetRowHeight; // TPE row
          height += 12;
        }
        
        const receivesCount = team.playersIn.length + incomingPicks.length + incomingRights.length + incomingCash;
        if (receivesCount > 0) {
          height += sectionLabelHeight;
          height += team.playersIn.length * playerRowHeight;
          height += incomingPicks.length * assetRowHeight;
          height += incomingRights.length * assetRowHeight;
          height += incomingCash * assetRowHeight;
          height += usesTPE * assetRowHeight; // TPE row
        }
        
        height += summaryHeight;
        return height;
      });
      const maxTeamHeight = Math.max(...teamHeights, 280);
      
      // Calculate canvas dimensions based on format
      let canvasWidth, canvasHeight;
      const contentWidth = (teamWidth * displayTeams.length) + (teamGap * (displayTeams.length - 1)) + (padding * 2);
      const contentHeight = headerHeight + maxTeamHeight + footerHeight + padding;
      
      if (currentImageFormat === 'stories') {
        canvasHeight = Math.max(contentHeight, 1200);
        canvasWidth = Math.round(canvasHeight * config.ratio);
      } else if (currentImageFormat === 'instagram') {
        canvasWidth = Math.max(contentWidth, 800);
        canvasHeight = canvasWidth;
      } else {
        canvasWidth = Math.max(contentWidth, 900);
        canvasHeight = Math.round(canvasWidth / config.ratio);
      }
      
      // Ensure content fits
      canvasHeight = Math.max(canvasHeight, contentHeight);
      
      // Set canvas size with 3x resolution for crisp output
      const scale = 3;
      tradeCanvas.width = canvasWidth * scale;
      tradeCanvas.height = canvasHeight * scale;
      tradeCanvas.style.width = canvasWidth + 'px';
      tradeCanvas.style.height = canvasHeight + 'px';
      ctx.scale(scale, scale);
      
      // Crisp rendering
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // Premium dark gradient background
      const bgGradient = ctx.createLinearGradient(0, 0, canvasWidth, canvasHeight);
      bgGradient.addColorStop(0, '#0f172a');
      bgGradient.addColorStop(0.5, '#1e293b');
      bgGradient.addColorStop(1, '#0f172a');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Subtle grid pattern overlay
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for (let i = 0; i < canvasWidth; i += 40) {
        ctx.fillRect(i, 0, 1, canvasHeight);
      }
      for (let i = 0; i < canvasHeight; i += 40) {
        ctx.fillRect(0, i, canvasWidth, 1);
      }
      
      // Header area with gradient
      const headerGradient = ctx.createLinearGradient(0, 0, 0, headerHeight);
      headerGradient.addColorStop(0, 'rgba(255,255,255,0.08)');
      headerGradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = headerGradient;
      ctx.fillRect(0, 0, canvasWidth, headerHeight);
      
      // Title - "NBA TRADE MACHINE"
      ctx.fillStyle = '#ffffff';
      ctx.font = '800 32px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('NBA TRADE MACHINE', canvasWidth / 2, 45);
      
      // Trade status badge
      const validation = validateTrade();
      const statusText = validation.valid ? '‚úì VALID TRADE' : '‚úï INVALID';
      ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
      const badgeWidth = ctx.measureText(statusText).width + 32;
      
      // Badge background with glow effect
      if (validation.valid) {
        ctx.shadowColor = 'rgba(34, 197, 94, 0.5)';
        ctx.shadowBlur = 20;
      } else {
        ctx.shadowColor = 'rgba(239, 68, 68, 0.5)';
        ctx.shadowBlur = 20;
      }
      ctx.fillStyle = validation.valid ? '#166534' : '#991b1b';
      ctx.beginPath();
      ctx.roundRect((canvasWidth - badgeWidth) / 2, 58, badgeWidth, 28, 14);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Badge border
      ctx.strokeStyle = validation.valid ? '#22c55e' : '#ef4444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect((canvasWidth - badgeWidth) / 2, 58, badgeWidth, 28, 14);
      ctx.stroke();
      
      // Badge text
      ctx.fillStyle = '#ffffff';
      ctx.fillText(statusText, canvasWidth / 2, 77);
      
      // Helper to draw circular image with border (maintains aspect ratio - cover mode)
      function drawCircularImage(img, x, y, size, borderColor = 'rgba(255,255,255,0.2)') {
        if (!img) return;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        
        // Calculate cover dimensions (maintain aspect ratio, fill circle)
        const imgRatio = img.width / img.height;
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imgRatio > 1) {
          // Image is wider than tall
          drawHeight = size;
          drawWidth = size * imgRatio;
          drawX = x - (drawWidth - size) / 2;
          drawY = y;
        } else {
          // Image is taller than wide
          drawWidth = size;
          drawHeight = size / imgRatio;
          drawX = x;
          drawY = y - (drawHeight - size) / 2;
        }
        
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        ctx.restore();
        
        // Border
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Helper to draw badge
      function drawBadge(x, y, badge) {
        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';
        const textWidth = ctx.measureText(badge.text).width;
        const badgeW = textWidth + 8;
        const badgeH = 16;
        
        ctx.fillStyle = badge.bg;
        ctx.beginPath();
        ctx.roundRect(x, y, badgeW, badgeH, 4);
        ctx.fill();
        
        ctx.fillStyle = badge.color;
        ctx.textAlign = 'center';
        ctx.fillText(badge.text, x + badgeW/2, y + 12);
        ctx.textAlign = 'left';
        
        return badgeW + 4;
      }
      
      // Center the teams
      const teamsContentWidth = (teamWidth * displayTeams.length) + (teamGap * (displayTeams.length - 1));
      const startX = (canvasWidth - teamsContentWidth) / 2;
      
      // Draw each team card
      displayTeams.forEach((team, teamIdx) => {
        const teamIndex = tradeTeams.indexOf(team);
        const x = startX + (teamIdx * (teamWidth + teamGap));
        const y = headerHeight + 8;
        const cardHeight = maxTeamHeight;
        
        const teamInfo = getTeamInfo(team.teamName);
        const { incomingPicks, incomingRights, incomingCash } = getIncomingAssets(teamIndex);
        
        // Card shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = 24;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 8;
        
        // Card background - premium white
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.roundRect(x, y, teamWidth, cardHeight, 16);
        ctx.fill();
        
        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        
        // Team header with subtle gradient
        const teamHeaderGrad = ctx.createLinearGradient(x, y, x, y + teamHeaderHeight);
        teamHeaderGrad.addColorStop(0, '#fafbfc');
        teamHeaderGrad.addColorStop(1, '#f1f5f9');
        ctx.fillStyle = teamHeaderGrad;
        ctx.beginPath();
        ctx.roundRect(x + 1, y + 1, teamWidth - 2, teamHeaderHeight - 1, [16, 16, 0, 0]);
        ctx.fill();
        
        // Header bottom border
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + teamHeaderHeight);
        ctx.lineTo(x + teamWidth, y + teamHeaderHeight);
        ctx.stroke();
        
        // Team logo - circular to handle transparent backgrounds
        const logoImg = teamInfo?.logo ? loadedImages.get(teamInfo.logo) : null;
        if (logoImg) {
          const logoSize = 52;
          const logoX = x + 16;
          const logoY = y + 14;
          
          // Draw circular clip for logo
          ctx.save();
          ctx.beginPath();
          ctx.arc(logoX + logoSize/2, logoY + logoSize/2, logoSize/2, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();
          
          // Fill with white background for logos that need it
          ctx.fillStyle = '#ffffff';
          ctx.fill();
          
          // Draw logo maintaining aspect ratio
          const imgRatio = logoImg.width / logoImg.height;
          let drawWidth, drawHeight, drawX, drawY;
          if (imgRatio > 1) {
            drawHeight = logoSize;
            drawWidth = logoSize * imgRatio;
            drawX = logoX - (drawWidth - logoSize) / 2;
            drawY = logoY;
          } else {
            drawWidth = logoSize;
            drawHeight = logoSize / imgRatio;
            drawX = logoX;
            drawY = logoY - (drawHeight - logoSize) / 2;
          }
          ctx.drawImage(logoImg, drawX, drawY, drawWidth, drawHeight);
          ctx.restore();
          
          // Subtle border
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(logoX + logoSize/2, logoY + logoSize/2, logoSize/2, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Team name
        ctx.fillStyle = '#0f172a';
        ctx.font = 'bold 20px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(team.teamName, x + (logoImg ? 78 : 20), y + 38);
        
        // Team status
        if (teamInfo) {
          ctx.fillStyle = '#64748b';
          ctx.font = '600 11px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.fillText(teamInfo.status.toUpperCase(), x + (logoImg ? 78 : 20), y + 56);
        }
        
        let currentY = y + teamHeaderHeight + 14;
        
        // Calculate if TPE is actually used (deficit exists)
        const outgoingForTPECalc = team.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
        const incomingForTPECalc = team.playersIn.reduce((sum, p) => sum + getIncomingSalary(p), 0);
        const deficitForTPECalc = incomingForTPECalc - outgoingForTPECalc;
        const usesTPE = (team.tpeUsed && deficitForTPECalc > 0) ? 1 : 0;
        
        // Trades section
        const sendsOutCount = team.playersOut.length + 
          (team.picksOut ? team.picksOut.length : 0) + 
          (team.rightsOut ? team.rightsOut.length : 0) +
          (team.cashOut ? team.cashOut.length : 0) +
          usesTPE;
          
        if (sendsOutCount > 0) {
          ctx.fillStyle = '#dc2626';
          ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText('TRADES', x + 16, currentY);
          currentY += 16;
          
          // Players with headshots and badges
          team.playersOut.forEach(player => {
            // Player card background
            ctx.fillStyle = '#fef2f2';
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, playerRowHeight - 6, 10);
            ctx.fill();
            
            // Border
            ctx.strokeStyle = '#fecaca';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, playerRowHeight - 6, 10);
            ctx.stroke();
            
            // Player headshot
            const headshotImg = player.headshot ? loadedImages.get(player.headshot) : null;
            const headshotSize = 40;
            if (headshotImg) {
              drawCircularImage(headshotImg, x + 18, currentY + 5, headshotSize, '#fecaca');
            } else {
              // Placeholder circle
              ctx.fillStyle = '#e5e7eb';
              ctx.beginPath();
              ctx.arc(x + 18 + headshotSize/2, currentY + 5 + headshotSize/2, headshotSize/2, 0, Math.PI * 2);
              ctx.fill();
            }
            
            // Player name
            ctx.fillStyle = '#0f172a';
            ctx.font = '600 13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            const nameX = x + 66;
            ctx.fillText(player.player, nameX, currentY + 20);
            
            // Badges next to name
            const badges = getPlayerBadges(player);
            let badgeX = nameX + ctx.measureText(player.player).width + 6;
            badges.slice(0, 2).forEach(badge => {
              badgeX += drawBadge(badgeX, currentY + 8, badge);
            });
            
            // Salary
            ctx.fillStyle = '#64748b';
            ctx.font = '500 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(formatSalary(player.salary), nameX, currentY + 38);
            currentY += playerRowHeight;
          });
          
          // Picks
          if (team.picksOut) {
            team.picksOut.forEach(pick => {
              ctx.fillStyle = '#fef3c7';
              ctx.beginPath();
              ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
              ctx.fill();
              
              ctx.strokeStyle = '#fcd34d';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
              ctx.stroke();
              
              ctx.fillStyle = '#92400e';
              ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
              ctx.textAlign = 'left';
              
              // Show pick origin if different from trading team
              const pickOrigin = pick.originalTeam && pick.originalTeam !== team.teamName 
                ? `${pick.originalTeam.split(' ').pop()}` : '';
              const pickText = pickOrigin 
                ? `üìã ${pick.year} ${pick.round} (${pickOrigin})` 
                : `üìã ${pick.year} ${pick.round} Round Pick`;
              ctx.fillText(pickText, x + 20, currentY + 23);
              currentY += assetRowHeight;
            });
          }
          
          // Rights
          if (team.rightsOut) {
            team.rightsOut.forEach(rights => {
              ctx.fillStyle = '#f3e8ff';
              ctx.beginPath();
              ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
              ctx.fill();
              
              ctx.strokeStyle = '#d8b4fe';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
              ctx.stroke();
              
              ctx.fillStyle = '#6b21a8';
              ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
              ctx.textAlign = 'left';
              ctx.fillText(`üéì Rights to ${rights.playerName}`, x + 20, currentY + 23);
              currentY += assetRowHeight;
            });
          }
          
          // Cash
          if (team.cashOut) {
            team.cashOut.forEach(() => {
              ctx.fillStyle = '#dcfce7';
              ctx.beginPath();
              ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
              ctx.fill();
              
              ctx.strokeStyle = '#86efac';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
              ctx.stroke();
              
              ctx.fillStyle = '#166534';
              ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
              ctx.textAlign = 'left';
              ctx.fillText('üíµ Cash Considerations', x + 20, currentY + 23);
              currentY += assetRowHeight;
            });
          }
          
          // TPE Used (shows in TRADES section as team is using/consuming TPE)
          if (usesTPE > 0 && team.tpeUsed) {
            const tpeAmountUsed = Math.min(team.tpeUsed.value, deficitForTPECalc);
            
            ctx.fillStyle = '#d1fae5';
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.fill();
            
            ctx.strokeStyle = '#6ee7b7';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.stroke();
            
            ctx.fillStyle = '#047857';
            ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`üìÑ TPE: ${formatSalary(tpeAmountUsed)}`, x + 20, currentY + 23);
            currentY += assetRowHeight;
          }
          
          currentY += 10;
        }
        
        // Acquires section
        const receivesCount = team.playersIn.length + incomingPicks.length + incomingRights.length + incomingCash;
        
        if (receivesCount > 0) {
          ctx.fillStyle = '#16a34a';
          ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText('ACQUIRES', x + 16, currentY);
          currentY += 16;
          
          // Players with headshots and badges
          team.playersIn.forEach(player => {
            ctx.fillStyle = '#eff6ff';
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, playerRowHeight - 6, 10);
            ctx.fill();
            
            ctx.strokeStyle = '#bfdbfe';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, playerRowHeight - 6, 10);
            ctx.stroke();
            
            // Player headshot
            const headshotImg = player.headshot ? loadedImages.get(player.headshot) : null;
            const headshotSize = 40;
            if (headshotImg) {
              drawCircularImage(headshotImg, x + 18, currentY + 5, headshotSize, '#bfdbfe');
            } else {
              ctx.fillStyle = '#e5e7eb';
              ctx.beginPath();
              ctx.arc(x + 18 + headshotSize/2, currentY + 5 + headshotSize/2, headshotSize/2, 0, Math.PI * 2);
              ctx.fill();
            }
            
            ctx.fillStyle = '#0f172a';
            ctx.font = '600 13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            const nameX = x + 66;
            ctx.fillText(player.player, nameX, currentY + 20);
            
            // Badges
            const badges = getPlayerBadges(player);
            let badgeX = nameX + ctx.measureText(player.player).width + 6;
            badges.slice(0, 2).forEach(badge => {
              badgeX += drawBadge(badgeX, currentY + 8, badge);
            });
            
            ctx.fillStyle = '#64748b';
            ctx.font = '500 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(formatSalary(player.salary), nameX, currentY + 38);
            currentY += playerRowHeight;
          });
          
          // Incoming Picks
          incomingPicks.forEach(pick => {
            ctx.fillStyle = '#fef3c7';
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.fill();
            
            ctx.strokeStyle = '#fcd34d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.stroke();
            
            ctx.fillStyle = '#92400e';
            ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`üìã ${pick.year} ${pick.round} Round Pick`, x + 20, currentY + 23);
            currentY += assetRowHeight;
          });
          
          // Incoming Rights
          incomingRights.forEach(rights => {
            ctx.fillStyle = '#f3e8ff';
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.fill();
            
            ctx.strokeStyle = '#d8b4fe';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.stroke();
            
            ctx.fillStyle = '#6b21a8';
            ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`üéì Rights to ${rights.playerName}`, x + 20, currentY + 23);
            currentY += assetRowHeight;
          });
          
          // Incoming Cash
          for (let i = 0; i < incomingCash; i++) {
            ctx.fillStyle = '#dcfce7';
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.fill();
            
            ctx.strokeStyle = '#86efac';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x + 12, currentY, teamWidth - 24, assetRowHeight - 6, 8);
            ctx.stroke();
            
            ctx.fillStyle = '#166534';
            ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('üíµ Cash Considerations', x + 20, currentY + 23);
            currentY += assetRowHeight;
          }
        }
        
        // Summary section at bottom
        const summaryY = y + cardHeight - summaryHeight;
        
        // Summary background
        ctx.fillStyle = '#f8fafc';
        ctx.beginPath();
        ctx.roundRect(x + 1, summaryY, teamWidth - 2, summaryHeight - 1, [0, 0, 16, 16]);
        ctx.fill();
        
        // Dashed separator
        ctx.strokeStyle = '#cbd5e1';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(x + 12, summaryY + 4);
        ctx.lineTo(x + teamWidth - 12, summaryY + 4);
        ctx.stroke();
        ctx.setLineDash([]);
        
        const outgoing = team.playersOut.reduce((sum, p) => sum + getOutgoingSalary(p), 0);
        const incomingCapImpact = team.playersIn.reduce((sum, p) => sum + getCapImpactSalary(p), 0);
        const net = incomingCapImpact - outgoing;
        
        // Outgoing
        ctx.fillStyle = '#64748b';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Outgoing', x + 16, summaryY + 28);
        ctx.textAlign = 'right';
        ctx.fillText(formatSalary(outgoing), x + teamWidth - 16, summaryY + 28);
        
        // Incoming
        ctx.textAlign = 'left';
        ctx.fillText('Incoming', x + 16, summaryY + 48);
        ctx.textAlign = 'right';
        ctx.fillText(formatSalary(incomingCapImpact), x + teamWidth - 16, summaryY + 48);
        
        // Net
        ctx.textAlign = 'left';
        ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.fillStyle = '#0f172a';
        ctx.fillText('Net', x + 16, summaryY + 72);
        
        ctx.textAlign = 'right';
        ctx.fillStyle = net > 0 ? '#dc2626' : net < 0 ? '#16a34a' : '#64748b';
        ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.fillText((net > 0 ? '+' : '') + formatSalary(net), x + teamWidth - 16, summaryY + 72);
      });
      
      // Footer
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '500 11px -apple-system, BlinkMacSystemFont, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('HoopsMatic.com NBA Trade Machine', canvasWidth / 2, canvasHeight - 14);
      
      // Set the image src (may fail if canvas is tainted by cross-origin images)
      try {
        generatedImage.src = tradeCanvas.toDataURL('image/png');
      } catch (e) {
        console.warn('Canvas tainted, headshots may not appear in export');
        // Still show something - regenerate without images would be complex
        // For now, the image will just show without the preview
      }
    }


    // Polyfill for roundRect if not available
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radii) {
        if (typeof radii === 'number') {
          radii = [radii, radii, radii, radii];
        }
        const [tl, tr, br, bl] = radii;
        this.beginPath();
        this.moveTo(x + tl, y);
        this.lineTo(x + width - tr, y);
        this.quadraticCurveTo(x + width, y, x + width, y + tr);
        this.lineTo(x + width, y + height - br);
        this.quadraticCurveTo(x + width, y + height, x + width - br, y + height);
        this.lineTo(x + bl, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - bl);
        this.lineTo(x, y + tl);
        this.quadraticCurveTo(x, y, x + tl, y);
        this.closePath();
      };
    }

    // ===========================================
    // HOOPSHYPE TRADE RUMORS INTEGRATION
    // ===========================================
    
    // Load latest + part7 + part6 for comprehensive coverage (via protected Cloudflare API)
    const RUMORS_URLS = [
      'https://hoopshype-rumors-api.thejorgesierra.workers.dev/api/rumors/latest',
      'https://hoopshype-rumors-api.thejorgesierra.workers.dev/api/rumors/part/7',
      'https://hoopshype-rumors-api.thejorgesierra.workers.dev/api/rumors/part/6'
    ];
    const MAX_RUMORS_PER_PLAYER = 10;
    let rumorsCache = null;

    async function fetchRumors() {
      if (rumorsCache) return rumorsCache;
      try {
        // Fetch all files in parallel with cache-busting for latest
        const cacheBuster = Date.now();
        const urls = RUMORS_URLS.map((url, i) => 
          i === 0 ? `${url}?cb=${cacheBuster}` : url
        );
        
        const responses = await Promise.all(urls.map(url => 
          fetch(url, { cache: 'no-store' }).catch(() => null)
        ));
        
        const dataArrays = await Promise.all(
          responses.map(r => r && r.ok ? r.json().catch(() => []) : [])
        );
        
        // Combine all rumors into one array
        const allRumors = dataArrays.flat();
        
        // Deduplicate based on source_url (same rumor shouldn't appear twice)
        const seen = new Set();
        rumorsCache = allRumors.filter(rumor => {
          const key = rumor.source_url || (rumor.text + rumor.archive_date);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
        
        return rumorsCache;
      } catch (error) {
        console.error('Error fetching rumors:', error);
        return [];
      }
    }

    function getTradeRumorsForEntity(rumors, entityName) {
      const entityLower = entityName.toLowerCase();
      
      const tradeRumors = rumors.filter(rumor => {
        const tags = rumor.tags || [];
        
        // Check if this is a trade rumor (tag includes Trade/Trades)
        const hasTradeTag = tags.some(tag => 
          tag.toLowerCase() === 'trade' || tag.toLowerCase() === 'trades'
        );
        
        // Check if entity is in tags
        const hasEntityTag = tags.some(tag => 
          tag.toLowerCase() === entityLower
        );
        
        return hasTradeTag && hasEntityTag;
      });
      
      tradeRumors.sort((a, b) => {
        const dateA = new Date(a.archive_date || a.date);
        const dateB = new Date(b.archive_date || b.date);
        return dateB - dateA;
      });
      
      return tradeRumors.slice(0, MAX_RUMORS_PER_PLAYER);
    }

    async function getRumorsForTrade(playersInTrade) {
      const rumors = await fetchRumors();
      if (!rumors.length) return {};
      
      const result = {};
      
      for (const player of playersInTrade) {
        let playerRumors = getTradeRumorsForEntity(rumors, player.name);
        
        if (playerRumors.length === 0 && player.team) {
          playerRumors = getTradeRumorsForEntity(rumors, player.team);
          result[player.name] = {
            rumors: playerRumors,
            fallbackToTeam: true,
            teamName: player.team
          };
        } else {
          result[player.name] = {
            rumors: playerRumors,
            fallbackToTeam: false
          };
        }
      }
      
      return result;
    }

    function formatRumorDate(rumor) {
      // Use archive_date for consistent formatting
      if (rumor.archive_date) {
        const date = new Date(rumor.archive_date + 'T12:00:00'); // Add time to avoid timezone issues
        return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
      }
      // Fallback to display date if no archive_date
      if (rumor.date && rumor.date.trim()) {
        return rumor.date;
      }
      return '';
    }

    function removeOutletFromText(text, outlet) {
      if (!text || !outlet) return text;
      
      // Clean outlet name variations
      const outletClean = outlet
        .replace(/^https?:\/\//, '')
        .replace(/^www\./, '')
        .replace(/\.com$|\.org$|\.net$|\.co$/, '')
        .trim();
      
      let result = text;
      
      // Remove outlet from end (various formats)
      const patterns = [
        // Exact outlet at end
        new RegExp('\\s*[-‚Äì‚Äî]?\\s*' + outletClean.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*$', 'i'),
        // With domain extension
        new RegExp('\\s*[-‚Äì‚Äî]?\\s*' + outletClean.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\.(com|org|net)\\s*$', 'i'),
        // Full outlet name
        new RegExp('\\s*[-‚Äì‚Äî]?\\s*' + outlet.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*$', 'i'),
      ];
      
      for (const pattern of patterns) {
        result = result.replace(pattern, '');
      }
      
      return result.trim();
    }
    
    function cleanupPunctuation(text) {
      if (!text) return text;
      
      let result = text;
      
      // Add space after colon if missing (but not in URLs)
      result = result.replace(/:([A-Za-z])/g, ': $1');
      
      // Add space after period if missing (but not in URLs or decimals)
      result = result.replace(/\.([A-Z])/g, '. $1');
      
      // Add space after comma if missing
      result = result.replace(/,([A-Za-z])/g, ', $1');
      
      // Remove double spaces
      result = result.replace(/\s+/g, ' ');
      
      return result.trim();
    }

    function formatOutlet(outlet) {
      if (!outlet) return '';
      return outlet
        .replace(/^https?:\/\//, '')
        .replace(/^www\./, '')
        .replace(/\.com$/, '')
        .replace(/\.org$/, '')
        .replace(/\.net$/, '');
    }

    function escapeHtmlRumors(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function renderRumorsSection(rumorsData) {
      const playersWithRumors = Object.entries(rumorsData).filter(
        ([_, data]) => data.rumors.length > 0
      );
      
      if (playersWithRumors.length === 0) {
        return '<div class="no-rumors">No recent trade rumors found for these players.</div>';
      }
      
      let html = `
        <div class="rumors-section">
          <div class="rumors-section-header">
            <span class="icon">üì∞</span>
            <h3>Recent Trade Rumors</h3>
          </div>
      `;
      
      for (const [playerName, data] of playersWithRumors) {
        const { rumors, fallbackToTeam, teamName } = data;
        
        html += `
          <div class="player-rumors">
            <div class="player-rumors-header">
              <h4>${fallbackToTeam ? teamName : playerName}</h4>
              ${fallbackToTeam ? `<span class="fallback-note">(no rumors for ${playerName})</span>` : ''}
              <span class="rumors-count-badge">${rumors.length} rumor${rumors.length !== 1 ? 's' : ''}</span>
            </div>
            <div class="rumors-list">
        `;
        
        for (const rumor of rumors) {
          const date = formatRumorDate(rumor);
          const outlet = formatOutlet(rumor.outlet);
          const sourceUrl = rumor.source_url || '#';
          const fullTextRaw = rumor.text || '';
          const fullTextCleaned = removeOutletFromText(fullTextRaw, rumor.outlet);
          const fullText = cleanupPunctuation(fullTextCleaned);
          const quote = rumor.quote || '';
          
          // Try to find quote in full text - check both cleaned and uncleaned versions
          let displayHtml = '';
          let quoteIndex = fullText.indexOf(quote);
          
          // If exact match not found, try the uncleaned version
          if (quoteIndex === -1 && quote) {
            quoteIndex = fullTextCleaned.indexOf(quote);
          }
          
          // If still not found, try finding in original text
          if (quoteIndex === -1 && quote) {
            quoteIndex = fullTextRaw.indexOf(quote);
          }
          
          if (fullText && quote && quoteIndex !== -1) {
            // Replace the quote portion with a bold, linked version
            const beforeQuote = escapeHtmlRumors(fullText.substring(0, quoteIndex));
            const afterQuote = escapeHtmlRumors(fullText.substring(quoteIndex + quote.length));
            const quotePart = sourceUrl && sourceUrl !== '#'
              ? `<a href="${sourceUrl}" target="_blank" rel="noopener"><strong>${escapeHtmlRumors(quote)}</strong></a>`
              : `<strong>${escapeHtmlRumors(quote)}</strong>`;
            displayHtml = beforeQuote + quotePart + afterQuote;
          } else if (fullText && quote) {
            // Quote exists but couldn't find it in text - bold the quote and append context
            const quotePart = sourceUrl && sourceUrl !== '#'
              ? `<a href="${sourceUrl}" target="_blank" rel="noopener"><strong>${escapeHtmlRumors(quote)}</strong></a>`
              : `<strong>${escapeHtmlRumors(quote)}</strong>`;
            // Just show the quote bolded since we can't reliably place it
            displayHtml = quotePart;
          } else if (fullText) {
            // No quote, just show full text with link on first sentence
            const firstSentenceEnd = fullText.search(/[.!?]/) + 1;
            if (firstSentenceEnd > 0 && sourceUrl && sourceUrl !== '#') {
              const firstPart = fullText.substring(0, firstSentenceEnd);
              const rest = fullText.substring(firstSentenceEnd);
              displayHtml = `<a href="${sourceUrl}" target="_blank" rel="noopener"><strong>${escapeHtmlRumors(firstPart)}</strong></a>${escapeHtmlRumors(rest)}`;
            } else {
              displayHtml = sourceUrl && sourceUrl !== '#'
                ? `<a href="${sourceUrl}" target="_blank" rel="noopener">${escapeHtmlRumors(fullText)}</a>`
                : escapeHtmlRumors(fullText);
            }
          } else if (quote) {
            // Only quote available
            displayHtml = sourceUrl && sourceUrl !== '#'
              ? `<a href="${sourceUrl}" target="_blank" rel="noopener"><strong>${escapeHtmlRumors(quote)}</strong></a>`
              : `<strong>${escapeHtmlRumors(quote)}</strong>`;
          }
          
          html += `
            <div class="rumor-item">
              <div class="rumor-meta">
                ${date ? `<span class="rumor-date">${date}</span>` : ''}
                ${outlet ? `<span class="rumor-outlet">via ${outlet}</span>` : ''}
              </div>
              <div class="rumor-text">
                ${displayHtml}
              </div>
            </div>
          `;
        }
        
        html += `
            </div>
          </div>
        `;
      }
      
      html += `
        </div>
      `;
      
      return html;
    }

    async function displayTradeRumors() {
      const container = document.getElementById('tradeRumorsContainer');
      if (!container) return;
      
      // Collect all players in the trade
      const playersInTrade = [];
      tradeTeams.forEach(team => {
        if (team.playersOut && team.playersOut.length > 0) {
          team.playersOut.forEach(p => {
            // Get full player info including team name
            const playerInfo = players.find(pl => pl.player === p.player);
            if (playerInfo) {
              playersInTrade.push({
                name: playerInfo.player,
                team: playerInfo.team
              });
            }
          });
        }
      });
      
      // If no players in trade, clear container
      if (playersInTrade.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      // Show loading state
      container.innerHTML = `
        <div class="rumors-section">
          <div class="rumors-loading">
            <div class="spinner">‚è≥</div>
            <div>Loading trade rumors...</div>
          </div>
        </div>
      `;
      
      try {
        const rumorsData = await getRumorsForTrade(playersInTrade);
        container.innerHTML = renderRumorsSection(rumorsData);
      } catch (error) {
        console.error('Error displaying rumors:', error);
        container.innerHTML = '';
      }
    }

    // Cache configuration
    const CACHE_KEY = 'nba_trade_calculator_data';
    const CACHE_VERSION_KEY = 'nba_trade_calculator_version';

    // Simple hash function for cache invalidation
    function hashCode(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash.toString();
    }

    function getCachedData() {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) return null;
        return JSON.parse(cached);
      } catch (e) {
        localStorage.removeItem(CACHE_KEY);
        return null;
      }
    }

    function setCachedData(csvText) {
      try {
        const hash = hashCode(csvText);
        localStorage.setItem(CACHE_KEY, JSON.stringify({ hash, csvText }));
      } catch (e) { /* localStorage full or disabled */ }
    }

    // Build initial trade from URL parameters
    function buildTradeFromUrl() {
      const params = new URLSearchParams(window.location.search);
      // Support both old format (players=, teams=) and new compact format (p=, t=)
      const playersParam = params.get('players') || params.get('p');
      const teamsParam = params.get('teams') || params.get('t');
      const playerDestsParam = params.get('pd'); // Player destinations
      const picksParam = params.get('picks') || params.get('pk');
      const rightsParam = params.get('rights') || params.get('r');
      const cashParam = params.get('cash') || params.get('c');
      
      // Detect if using new compact format (player IDs instead of names)
      const isCompactFormat = params.has('p') || params.has('t');
      
      if (!playersParam && !teamsParam) return null;
      
      // Parse player identifiers (IDs or slugs)
      const playerIdentifiers = playersParam ? playersParam.split(',').map(s => s.trim()) : [];
      
      // Parse team identifiers (abbreviations or slugs)
      const teamIdentifiers = teamsParam ? teamsParam.split(',').map(s => s.trim()) : [];
      
      // Parse player destinations (format: fromTeamIdx-destIdx,...)
      const playerDests = playerDestsParam ? playerDestsParam.split(',').map(d => {
        const parts = d.split('-');
        return { fromTeamIdx: parseInt(parts[0]) || 0, destIdx: parts[1] !== '' ? parseInt(parts[1]) : undefined };
      }) : [];
      
      // Match identifiers to actual players
      const matchedPlayers = [];
      playerIdentifiers.forEach((identifier, idx) => {
        let player;
        
        // Check if it's a numeric player ID
        if (/^\d+$/.test(identifier)) {
          player = players.find(p => p.playerId === identifier);
        }
        
        // Fall back to slug matching
        if (!player) {
          const slugLower = identifier.toLowerCase().replace(/-/g, '');
          player = players.find(p => {
            const playerSlug = p.player.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            return playerSlug === slugLower || playerSlug.includes(slugLower) || slugLower.includes(playerSlug);
          });
        }
        
        if (player) {
          const dest = playerDests[idx];
          matchedPlayers.push({
            ...player,
            urlFromTeamIdx: dest ? dest.fromTeamIdx : undefined,
            urlDestIdx: dest ? dest.destIdx : undefined
          });
        }
      });
      
      // Match identifiers to actual teams
      const matchedTeams = [];
      teamIdentifiers.forEach(identifier => {
        let team;
        
        // Check if it's a team abbreviation
        const upperIdent = identifier.toUpperCase();
        if (abbrevToTeam[upperIdent]) {
          team = abbrevToTeam[upperIdent];
        }
        
        // Fall back to slug matching
        if (!team) {
          const slugLower = identifier.toLowerCase().replace(/-/g, '');
          team = teams.find(t => {
            const teamSlug = t.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            return teamSlug === slugLower || teamSlug.includes(slugLower) || slugLower.includes(teamSlug);
          });
        }
        
        if (team && !matchedTeams.includes(team)) matchedTeams.push(team);
      });
      
      // Also add teams from matched players
      matchedPlayers.forEach(p => {
        if (p.team && !matchedTeams.includes(p.team)) {
          matchedTeams.push(p.team);
        }
      });
      
      if (matchedTeams.length < 2) return null;
      
      // Create trade teams
      const tradeTeamsList = matchedTeams.slice(0, 5).map(teamName => ({
        teamName,
        playersOut: [],
        playersIn: [],
        tpeUsed: null,
        picksOut: [],
        rightsOut: [],
        cashOut: []
      }));
      
      // Assign players to correct teams based on URL destinations
      matchedPlayers.forEach(p => {
        // Find which trade team this player's team belongs to
        const teamIdx = tradeTeamsList.findIndex(t => t.teamName === p.team);
        if (teamIdx !== -1) {
          const playerCopy = { ...p };
          // Use URL destination if available, otherwise default based on team count
          if (p.urlDestIdx !== undefined) {
            playerCopy.destination = p.urlDestIdx;
          } else if (tradeTeamsList.length === 2) {
            playerCopy.destination = teamIdx === 0 ? 1 : 0;
          } else {
            playerCopy.destination = (teamIdx + 1) % tradeTeamsList.length;
          }
          tradeTeamsList[teamIdx].playersOut.push(playerCopy);
        }
      });
      
      // Parse and add picks (format: fromTeamIdx:pickTeam:year:round:destIdx,...)
      // Supports both old format (team slugs, "1st"/"2nd") and new compact format (abbreviations, "1"/"2")
      if (picksParam) {
        const pickStrings = picksParam.split(',');
        pickStrings.forEach(pickStr => {
          const parts = pickStr.split(':');
          if (parts.length >= 4) {
            const fromTeamIdx = parseInt(parts[0]) || 0;
            const pickTeamIdent = parts[1];
            const year = parts[2];
            let round = parts[3];
            const destIdx = parts[4] !== undefined && parts[4] !== '' ? parseInt(parts[4]) : undefined;
            
            // Convert short round format to full format
            if (round === '1') round = '1st';
            if (round === '2') round = '2nd';
            
            // Find the actual pick team name (try abbreviation first, then slug)
            let pickTeamName;
            const upperIdent = pickTeamIdent.toUpperCase();
            if (abbrevToTeam[upperIdent]) {
              pickTeamName = abbrevToTeam[upperIdent];
            } else {
              const pickTeamSlug = pickTeamIdent.toLowerCase().replace(/-/g, '');
              pickTeamName = teams.find(t => {
                const teamSlug = t.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                return teamSlug === pickTeamSlug || teamSlug.includes(pickTeamSlug) || pickTeamSlug.includes(teamSlug);
              });
            }
            
            // Find the matching draft pick
            if (pickTeamName && fromTeamIdx < tradeTeamsList.length) {
              const matchingPick = draftPicks.find(dp => 
                dp.team === pickTeamName && 
                dp.year === year && 
                dp.round === round
              );
              
              if (matchingPick) {
                tradeTeamsList[fromTeamIdx].picksOut.push({
                  ...matchingPick,
                  destination: destIdx !== undefined ? destIdx : (fromTeamIdx === 0 ? 1 : 0)
                });
              }
            }
          }
        });
      }
      
      // Parse and add draft rights (format: fromTeamIdx:playerName:destIdx,...)
      if (rightsParam) {
        const rightsStrings = rightsParam.split(',');
        rightsStrings.forEach(rightsStr => {
          const parts = rightsStr.split(':');
          if (parts.length >= 2) {
            const fromTeamIdx = parseInt(parts[0]) || 0;
            const playerSlug = parts[1].toLowerCase().replace(/-/g, '');
            const destIdx = parts[2] !== undefined && parts[2] !== '' ? parseInt(parts[2]) : undefined;
            
            // Find the matching draft rights
            if (fromTeamIdx < tradeTeamsList.length) {
              const matchingRights = draftRights.find(dr => {
                const drSlug = dr.playerName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                return drSlug === playerSlug || drSlug.includes(playerSlug) || playerSlug.includes(drSlug);
              });
              
              if (matchingRights) {
                if (!tradeTeamsList[fromTeamIdx].rightsOut) {
                  tradeTeamsList[fromTeamIdx].rightsOut = [];
                }
                tradeTeamsList[fromTeamIdx].rightsOut.push({
                  ...matchingRights,
                  destination: destIdx !== undefined ? destIdx : (fromTeamIdx === 0 ? 1 : 0)
                });
              }
            }
          }
        });
      }
      
      // Parse and add cash (format: fromTeamIdx:destIdx,...)
      if (cashParam) {
        const cashStrings = cashParam.split(',');
        cashStrings.forEach(cashStr => {
          const parts = cashStr.split(':');
          if (parts.length >= 1) {
            const fromTeamIdx = parseInt(parts[0]) || 0;
            const destIdx = parts[1] !== undefined && parts[1] !== '' ? parseInt(parts[1]) : undefined;
            
            if (fromTeamIdx < tradeTeamsList.length) {
              if (!tradeTeamsList[fromTeamIdx].cashOut) {
                tradeTeamsList[fromTeamIdx].cashOut = [];
              }
              tradeTeamsList[fromTeamIdx].cashOut.push({
                destination: destIdx !== undefined ? destIdx : (fromTeamIdx === 0 ? 1 : 0)
              });
            }
          }
        });
      }
      
      // Rebuild playersIn based on destinations
      tradeTeamsList.forEach(t => t.playersIn = []);
      tradeTeamsList.forEach((team, teamIndex) => {
        team.playersOut.forEach(player => {
          if (player.destination !== undefined && player.destination !== teamIndex) {
            const destTeam = tradeTeamsList[player.destination];
            if (destTeam) {
              destTeam.playersIn.push(player);
            }
          }
        });
      });
      
      return tradeTeamsList;
    }

    // Setup trade loop from URL parameters
    // URL format: ?loop=1&player=Giannis-Antetokounmpo&to=LA-Lakers&exclude=Luka-Doncic
    function setupTradeLoopFromUrl() {
      // Use the captured initial params (before any URL modifications)
      const params = INITIAL_URL_PARAMS;
      const loopParam = params.get('loop');
      const playerParam = params.get('player');
      const fromParam = params.get('from');
      const toParam = params.get('to');
      const excludeParam = params.get('exclude');
      
      // If no loop-related params, skip
      if (!loopParam && !playerParam && !fromParam && !toParam && !excludeParam) {
        return;
      }
      
      // Match player(s) from URL
      if (playerParam) {
        const playerSlugs = playerParam.split(',').map(s => s.trim());
        playerSlugs.forEach(slug => {
          const slugLower = slug.toLowerCase().replace(/-/g, '');
          const player = players.find(p => {
            const playerSlug = p.player.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            return playerSlug === slugLower || playerSlug.includes(slugLower) || slugLower.includes(playerSlug);
          });
          if (player && !unifiedSelectedPlayers.some(p => p.player === player.player)) {
            unifiedSelectedPlayers.push(player);
          }
        });
        renderUnifiedPlayerChips();
      }
      
      // Match "from" team
      if (fromParam && !unifiedSelectedPlayers.length) {
        const slugLower = fromParam.toLowerCase().replace(/-/g, '');
        const team = teams.find(t => {
          const teamSlug = t.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
          return teamSlug === slugLower || teamSlug.includes(slugLower) || slugLower.includes(teamSlug);
        });
        if (team) {
          unifiedOriginTeam = team;
          document.getElementById('unifiedOriginInput').value = team;
        }
      }
      
      // Match "to" team
      if (toParam) {
        const slugLower = toParam.toLowerCase().replace(/-/g, '');
        const team = teams.find(t => {
          const teamSlug = t.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
          return teamSlug === slugLower || teamSlug.includes(slugLower) || slugLower.includes(teamSlug);
        });
        if (team) {
          unifiedDestTeam = team;
          document.getElementById('unifiedDestInput').value = team;
        }
      }
      
      // Match excluded player(s)
      if (excludeParam) {
        const excludeSlugs = excludeParam.split(',').map(s => s.trim());
        excludeSlugs.forEach(slug => {
          const slugLower = slug.toLowerCase().replace(/-/g, '');
          const player = players.find(p => {
            const playerSlug = p.player.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
            return playerSlug === slugLower || playerSlug.includes(slugLower) || slugLower.includes(playerSlug);
          });
          if (player && !excludedPlayers.includes(player.player)) {
            excludedPlayers.push(player.player); // Push string name, not object
          }
        });
        renderExcludedChips();
      }
      
      // If loop=1, generate trade and start loop
      if (loopParam === '1' || loopParam === 'true') {
        // Generate first trade
        setTimeout(() => {
          const result = generateUnifiedTrade();
          if (result && !result.error) {
            // Apply the trade
            tradeTeams = result;
            redistributePlayers(true);
            render();
            // Start the loop
            startLoop();
          }
        }, 100);
      } else if (playerParam || fromParam || toParam) {
        // Just generate one trade with the settings
        setTimeout(() => {
          const result = generateUnifiedTrade();
          if (result && !result.error) {
            tradeTeams = result;
            redistributePlayers(true);
            render();
          }
        }, 100);
      }
    }

    // Build initial trade from rumors data
    function buildTradeFromRumors() {
      if (!initialRumorsData || !initialRumorsData.length || !players.length) {
        return null;
      }
      
      // Get trade rumors from last 7 days
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      
      const tradeRumors = initialRumorsData.filter(rumor => {
        const tags = rumor.tags || [];
        const hasTradeTag = tags.some(t => t.toLowerCase() === 'trade' || t.toLowerCase() === 'trades');
        if (!hasTradeTag) return false;
        
        // Check date
        const rumorDate = new Date(rumor.archive_date || rumor.date);
        return rumorDate >= sevenDaysAgo;
      });
      
      if (!tradeRumors.length) return null;
      
      // Count player mentions in trade rumors
      const rumoredPlayers = new Map();
      
      tradeRumors.forEach(rumor => {
        const tags = rumor.tags || [];
        tags.forEach(tag => {
          // Check if tag matches a player name
          const matchedPlayer = players.find(p => 
            p.player.toLowerCase() === tag.toLowerCase() ||
            p.player.toLowerCase().includes(tag.toLowerCase()) ||
            tag.toLowerCase().includes(p.player.split(' ').pop().toLowerCase())
          );
          // Only meaningful salary players who can be traded
          if (matchedPlayer && matchedPlayer.salary > 5000000 && !matchedPlayer.is10Day) {
            const count = rumoredPlayers.get(matchedPlayer.player) || 0;
            rumoredPlayers.set(matchedPlayer.player, count + 1);
          }
        });
      });
      
      if (rumoredPlayers.size === 0) return null;
      
      // Get the most mentioned player (with some randomization among top 15)
      const sortedPlayers = [...rumoredPlayers.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15)
        .map(([name]) => players.find(p => p.player === name))
        .filter(Boolean);
      
      if (sortedPlayers.length === 0) return null;
      
      // Pick randomly from top rumored players
      const rumoredPlayer = sortedPlayers[Math.floor(Math.random() * sortedPlayers.length)];
      
      // Pick a random different team
      const otherTeams = teams.filter(t => t !== rumoredPlayer.team);
      const randomTeam = otherTeams[Math.floor(Math.random() * otherTeams.length)];
      
      if (!randomTeam) return null;
      
      // Create trade: rumored player on their team, random opposing team empty
      const playerOut = { ...rumoredPlayer, destination: 1 };
      
      return [
        { 
          teamName: rumoredPlayer.team, 
          playersOut: [playerOut], 
          playersIn: [], 
          tpeUsed: null, 
          picksOut: [], 
          rightsOut: [], 
          cashOut: [] 
        },
        { 
          teamName: randomTeam, 
          playersOut: [], 
          playersIn: [], 
          tpeUsed: null, 
          picksOut: [], 
          rightsOut: [], 
          cashOut: [] 
        }
      ];
    }

    function processCSVData(results) {
      players = results.data
        .filter(row => row.PLAYER && row.PLAYER.trim())
        .filter(row => row.TEAM && row.TEAM.trim())
        .map(row => {
          const otherNotes = row['OTHER NOTES']?.trim() || '';
          const contractStatus = row['ST 25-26']?.trim() || '';
          const is10Day = contractStatus.toLowerCase().includes('10-day');
          const tradeKickerValue = parseFloat(row['TRADE KICKER'] || 0) || 0;
          return {
            player: row.PLAYER?.trim() || '',
            team: row.TEAM?.trim() || '',
            salary: parseSalary(row['2026']),
            contractStatus: contractStatus,
            teamStatus: row['TEAM STATUS']?.trim() || '',
            capSpace: parseSalary(row['CAP SPACE'] || row['Cap Space'] || row['H'] || 0),
            globalRating: parseFloat(row['RAT 365'] || 0) || 0,
            gamesPlayed: parseInt(row['GAMES'] || 0) || 0,
            position: row['POSITION']?.trim() || '',
            age: (row['AGE'] != null ? row['AGE'].toString().trim() : ''),
            contractEnd: row['END']?.trim() || '',
            guaranteedMoney: parseSalary(row['TOTAL GUARANTEED'] || 0),
            noTradeClause: (row['NO TRADE'] || '').toString().trim().toUpperCase() === 'YES',
            noTradeTo: (row['NO TRADE TO'] || '').toString().trim(),
            notAggregated: (row['NOT AGGREGATED'] || '').toString().trim().toUpperCase() === 'NO',
            poisonPill: parseSalary(row['POISON PILL'] || 0),
            tradeKicker: tradeKickerValue,
            otherNotes: otherNotes,
            exception: row['EXCEPTION']?.trim() || '',
            isMinimum: otherNotes.toLowerCase().includes('minimum'),
            isMinSalaryException: (row['EXCEPTION']?.trim() || '').toLowerCase().includes('minimum salary exception'),
            is10Day: is10Day,
            taxRoom: parseSalary(row['TAX ROOM'] || 0),
            apronRoom1st: parseSalary(row['1st APRON'] || 0),
            apronRoom2nd: parseSalary(row['2nd APRON'] || 0),
            isHardcap1st: (row['HARD CAP 1st?'] || '').toString().trim().toLowerCase().includes('hc'),
            isHardcap2nd: (row['HARD CAP 2nd?'] || '').toString().trim().toLowerCase().includes('hc'),
            tradeAvailable: is10Day ? 'not available' : (row['RESTRICTIONS']?.trim() || ''),
            isOut: (row['OUT?'] || '').toString().trim().toUpperCase() === 'OUT',
            injuryReason: row['REASON']?.trim() || '',
            teamLogo: row['LOGO']?.trim() || row['Logo']?.trim() || row['TEAM LOGO']?.trim() || row['Team Logo']?.trim() || '',
            headshot: row['HEADSHOT']?.trim() || row['Headshot']?.trim() || row['PLAYER HEADSHOT']?.trim() || '',
            // Extract player ID from headshot URL (e.g., .../260x190/203944.png -> 203944)
            playerId: (() => {
              const hs = row['HEADSHOT']?.trim() || row['Headshot']?.trim() || row['PLAYER HEADSHOT']?.trim() || '';
              const match = hs.match(/\/(\d+)\.png/);
              return match ? match[1] : '';
            })(),
            capHold: parseSalary(row['CH 25-26'] || row['CAP HOLD'] || 0),
            unlikelyBonus: parseSalary(row['UNLIKELY BONUS'] || 0)
          };
        });

      teams = getUniqueTeams();
      
      tradeExceptions = results.data
        .filter(row => row['TRADE EXCEPTION'] && row['TRADE EXCEPTION'].trim())
        .map(row => {
          let value = parseSalary(row['VALUE'] || 0);
          let date = row['DATE']?.trim() || '';
          if (value < 100 && date && date.includes('$')) {
            value = parseSalary(date);
            date = row['VALUE']?.trim() || '';
          }
          return { team: row['TRADE EXCEPTION']?.trim() || '', value, expirationDate: date };
        })
        .filter(tpe => tpe.value > 0);
      
      draftPicks = results.data
        .filter(row => {
          if (!row['DRAFT TEAM']?.trim()) return false;
          if (!row['DRAFT YEAR']?.toString().trim()) return false;
          const round = row['ROUND']?.toString().trim().toLowerCase();
          if (!round || (round !== '1st' && round !== '2nd')) return false;
          const year = row['DRAFT YEAR']?.toString().trim();
          if (!year || isNaN(parseInt(year))) return false;
          const yearNum = parseInt(year);
          return yearNum >= 2025 && yearNum <= 2035;
        })
        .map(row => ({
          team: row['DRAFT TEAM']?.trim() || '',
          round: row['ROUND']?.trim() || '1st',
          year: row['DRAFT YEAR']?.toString().trim() || '',
          surePick: row['SURE PICK?']?.toString().trim().toUpperCase() || 'NO',
          notes: row['NOTES']?.trim() || '',
          linkedTo: row['LINKED TO']?.toString().trim() || ''
        }));
      
      draftRights = results.data
        .filter(row => row['DRAFT RIGHTS']?.trim() && row['TEAM RIGHTS']?.trim())
        .map(row => ({
          playerName: row['DRAFT RIGHTS']?.trim() || '',
          draftedYear: row['DRAFTED YEAR']?.toString().trim() || '',
          team: row['TEAM RIGHTS']?.trim() || ''
        }));
      
      // Check if this is a loop URL (uses player= singular) vs a trade URL (uses players= plural)
      if (!IS_LOOP_URL) {
        // Try to build initial trade from URL parameters first (for shared trades)
        const urlTrade = buildTradeFromUrl();
        if (urlTrade) {
          tradeTeams = urlTrade;
        } else {
          // Try to build initial trade from rumors, fall back to weighted random teams
          const rumorsBasedTrade = buildTradeFromRumors();
          if (rumorsBasedTrade) {
            tradeTeams = rumorsBasedTrade;
          } else {
            const [team1, team2] = selectTwoWeightedTeams(teams);
            tradeTeams = [
              { teamName: team1 || '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
              { teamName: team2 || '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
            ];
          }
        }
      } else {
        // For loop URLs, start with default teams - setupTradeLoopFromUrl will handle the rest
        const [team1, team2] = selectTwoWeightedTeams(teams);
        tradeTeams = [
          { teamName: team1 || '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] },
          { teamName: team2 || '', playersOut: [], playersIn: [], tpeUsed: null, picksOut: [], rightsOut: [], cashOut: [] }
        ];
      }
      
      redistributePlayers();
      loadingState.style.display = 'none';
      render();
      
      // Fetch global trade stats (use pre-started fetch for speed, re-render when done)
      fetchTradeStats(true).then(() => render());
      
      // Check for trade loop URL parameters
      setupTradeLoopFromUrl();
      
      // Add pulse hint to team selects on first load (shows they're clickable)
      setTimeout(() => {
        document.querySelectorAll('.team-select').forEach(select => {
          select.classList.add('pulse-hint');
        });
        // Remove after animation completes
        setTimeout(() => {
          document.querySelectorAll('.team-select').forEach(select => {
            select.classList.remove('pulse-hint');
          });
        }, 3000);
      }, 500);
    }

    async function loadData() {
      const cached = getCachedData();
      
      // Hide loading content if we have cache (will show real content instantly)
      if (cached) {
        const loadingContent = document.getElementById('loadingContent');
        const loadingStatus = document.getElementById('loadingStatus');
        if (loadingContent) loadingContent.style.display = 'none';
        if (loadingStatus) loadingStatus.style.display = 'none';
        
        Papa.parse(cached.csvText, {
          header: true,
          skipEmptyLines: true,
          complete: processCSVData,
          error: () => {}
        });
      }
      
      // Use the pre-started fetch (already running in parallel)
      try {
        const csvText = await csvFetchPromise;
        if (!csvText) throw new Error('Fetch failed');
        
        const newHash = hashCode(csvText);
        
        // If hash changed (or no cache), update the data
        if (!cached || cached.hash !== newHash) {
          setCachedData(csvText);
          
          Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
            complete: processCSVData,
            error: (error) => {
              console.error('Parse error:', error);
              if (!cached) {
                loadingState.innerHTML = '<p>Error loading data. Please refresh the page.</p>';
              }
            }
           });
        }
      } catch (error) {
        console.error('Fetch error:', error);
        if (!cached) {
          loadingState.innerHTML = '<p>Error loading data. Please refresh the page.</p>';
        }
      }
    }

    loadData();
  </script>
</body>
</html>
